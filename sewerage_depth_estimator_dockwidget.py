# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SewerageDepthEstimatorDockWidget
                                 A QGIS plugin
 Estimate the depth of sewer network based on simplified parameters
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-08
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonardo Nazareth
        email                : leonazareth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject, QgsMapLayer, QgsCoordinateReferenceSystem
try:
    from qgis.gui import QgsProjectionSelectionWidget
except Exception:  # pragma: no cover - optional in some envs
    QgsProjectionSelectionWidget = None
from qgis.gui import QgsColorButton

from .elevation_floater import ElevationFloaterController
from .change_manager_integration import ChangeManagerIntegration

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'sewerage_depth_estimator_dockwidget_base.ui'))


class SewerageDepthEstimatorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface=None, parent=None):
        """Constructor."""
        super(SewerageDepthEstimatorDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # QGIS iface and canvas
        self.iface = iface
        self.canvas = self.iface.mapCanvas() if self.iface else None

        # Elevation floater controller (non-intrusive, does not change active tool)
        self._floater = ElevationFloaterController(self.iface) if self.iface else None
        
        # Change management system for automatic updates - using enhanced system
        self._change_integration = ChangeManagerIntegration()

        # Wire checkbox
        if hasattr(self, 'chkEstimateDepth'):
            self.chkEstimateDepth.toggled.connect(self._on_toggle_estimator)

        # Populate DEM layers and watch project changes
        self._populate_dem_layers()
        QgsProject.instance().layersAdded.connect(self._populate_dem_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_dem_layers)
        QgsProject.instance().layerWasAdded.connect(self._populate_dem_layers)
        # Populate vector line layers for Layers tab
        self._populate_line_layers()
        QgsProject.instance().layersAdded.connect(self._populate_line_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_line_layers)
        
        # Initialize color buttons BEFORE loading project config so they exist when colors are loaded
        self._init_color_buttons()
        
        # Load saved project configuration AFTER both DEM and Line layer combos and color buttons are ready
        # so that saved selections can be restored correctly.
        self._load_project_config()
        if hasattr(self, 'cmbLineLayer'):
            self.cmbLineLayer.currentIndexChanged.connect(self._on_line_layer_changed)
            self._push_gate_layer_to_floater()
            # Set up initial selection monitoring
            self._connect_selection_monitoring()
        if hasattr(self, 'cmbDemLayer'):
            self.cmbDemLayer.currentIndexChanged.connect(self._on_dem_layer_changed)
        # No CRS selection widget; measure CRS will follow the vector layer
        # Parameters wiring
        if hasattr(self, 'spnMinCover'):
            self.spnMinCover.valueChanged.connect(self._on_params_changed_with_change_management)
        if hasattr(self, 'spnDiameter'):
            self.spnDiameter.valueChanged.connect(self._on_params_changed_with_change_management)
        if hasattr(self, 'spnSlope'):
            self.spnSlope.valueChanged.connect(self._on_params_changed_with_change_management)
        if hasattr(self, 'spnInitialDepth'):
            self.spnInitialDepth.valueChanged.connect(self._on_params_changed)
        # Display toggles
        if hasattr(self, 'chkShowExt'):
            self.chkShowExt.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowElev'):
            self.chkShowElev.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowDepth'):
            self.chkShowDepth.toggled.connect(self._on_display_changed)
        # Display styling controls
        if hasattr(self, 'fontCombo'):
            self.fontCombo.currentFontChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnFontSize'):
            self.spnFontSize.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'chkBoldLabels'):
            self.chkBoldLabels.toggled.connect(self._on_style_changed)
        if hasattr(self, 'cmbLabelLayout'):
            self.cmbLabelLayout.currentIndexChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnCornerRadius'):
            self.spnCornerRadius.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetX'):
            self.spnOffsetX.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetY'):
            self.spnOffsetY.valueChanged.connect(self._on_style_changed)
        # Restore default style button
        if hasattr(self, 'btnRestoreDefaultStyle'):
            self.btnRestoreDefaultStyle.clicked.connect(self._on_restore_default_style)
        # Recalculate selected segments button
        if hasattr(self, 'btnRecalculateSelected'):
            self.btnRecalculateSelected.clicked.connect(self._on_recalculate_selected)
        # Apply style button
        if hasattr(self, 'btnApplyStyle'):
            self.btnApplyStyle.clicked.connect(self._on_apply_style)

        # Initialize floater params
        self._push_params_to_floater()
        self._push_display_to_floater()
        # Measure CRS will be pushed when vector layer is set
        # Push initial style to floater
        self._push_style_to_floater()
        
        # Initialize change management system if layers are already available
        self._initialize_change_management()

    def closeEvent(self, event):
        # Ensure floater is removed when closing
        try:
            if self._floater:
                self._floater.stop()
        except Exception:
            pass
        # Cleanup change management system
        try:
            if self._change_integration:
                self._change_integration.cleanup()
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layerWasAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_line_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_line_layers)
        except Exception:
            pass
        self.closingPlugin.emit()
        event.accept()

    # --- internal -------------------------------------------------------------
    def _pick_first_raster_layer(self):
        if QgsProject.instance() is None:
            return None
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    return lyr
            except Exception:
                continue
        return None

    def _current_dem_layer(self):
        if not hasattr(self, 'cmbDemLayer'):
            return None
        lyr_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _current_band(self) -> int:
        # DEMs are assumed single-band per requirement
        return 1

    def _populate_dem_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbDemLayer'):
            return
        prev_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        self.cmbDemLayer.blockSignals(True)
        self.cmbDemLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    self.cmbDemLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbDemLayer.blockSignals(False)
        # Restore selection if possible
        if prev_id:
            idx = self.cmbDemLayer.findData(prev_id)
            if idx >= 0:
                self.cmbDemLayer.setCurrentIndex(idx)
        # No band selection (assume band 1)

    # Removed band population; fixed to band 1

    def _on_dem_layer_changed(self, idx: int):
        # If running, restart with the new layer
        if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
            self._restart_floater()
        # Warn if CRS differs between DEM and vector layer
        try:
            dem = self._current_dem_layer()
            vec = self._current_line_layer()
            if dem is not None and vec is not None and dem.crs().isValid() and vec.crs().isValid():
                if dem.crs() != vec.crs() and self.iface:
                    self.iface.messageBar().pushWarning(
                        self.tr("Sewerage Depth Estimator"),
                        self.tr("CRS mismatch between DEM (%1) and vector layer (%2).").replace("%1", dem.crs().authid()).replace("%2", vec.crs().authid())
                    )
        except Exception:
            pass
        # Save configuration
        self._save_project_config()
        
        # Initialize change management system when DEM layer changes
        self._initialize_change_management()

    # Removed band change handler

    def _restart_floater(self):
        if not self._floater:
            return
        lyr = self._current_dem_layer() or self._pick_first_raster_layer()
        if lyr is None:
            if self.iface:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)
            return
        try:
            self._floater.stop()
            self._floater.start(lyr, band=1, number_format="{value:.2f}")
        except Exception:
            if self.iface:
                self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)

    def _on_toggle_estimator(self, enabled: bool):
        if not self._floater:
            return
        if enabled:
            layer = self._current_dem_layer() or self._pick_first_raster_layer()
            if layer is None:
                # Fallback: disable and inform user via message bar if iface is present
                if self.iface:
                    self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
                return
            try:
                self._floater.start(layer, band=1, number_format="{value:.2f}")
                # Start change monitoring when depth estimation is enabled
                self._start_change_monitoring_if_available()
            except Exception:
                if self.iface:
                    self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
        else:
            self._floater.stop()
            # Stop change monitoring when depth estimation is disabled
            self._stop_change_monitoring_if_available()

    def _on_params_changed(self, *args):
        self._push_params_to_floater()
        self._save_project_config()

    def _push_params_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.minimum_cover_m = float(self.spnMinCover.value())
            # Diameter is shown in mm in UI; convert to meters for calculations
            self._floater.diameter_m = float(self.spnDiameter.value()) / 1000.0
            self._floater.slope_m_per_m = float(self.spnSlope.value())
            self._floater.initial_depth_m = float(self.spnInitialDepth.value())
        except Exception:
            pass

    def _on_display_changed(self, *args):
        self._push_display_to_floater()
        self._save_project_config()

    def _push_display_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.show_extension = bool(self.chkShowExt.isChecked())
            self._floater.show_elevation = bool(self.chkShowElev.isChecked())
            self._floater.show_depth = bool(self.chkShowDepth.isChecked())
        except Exception:
            pass

    # --- CRS measure handling --------------------------------------------------
    def _init_measure_crs(self):
        # No-op: measure CRS follows vector layer CRS now
        return

    def _on_measure_crs_changed(self):
        # No-op: widget removed
        return

    # --- Layers tab population -------------------------------------------------
    def _populate_line_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbLineLayer'):
            return
        prev_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        self.cmbLineLayer.blockSignals(True)
        self.cmbLineLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.VectorLayer and lyr.geometryType() in (1, 5):  # 1 Line, 5 MultiLine
                    self.cmbLineLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbLineLayer.blockSignals(False)
        if prev_id:
            idx = self.cmbLineLayer.findData(prev_id)
            if idx >= 0:
                self.cmbLineLayer.setCurrentIndex(idx)
        self._populate_numeric_fields()

    def _current_line_layer(self):
        if not hasattr(self, 'cmbLineLayer'):
            return None
        lyr_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _populate_numeric_fields(self):
        lyr = self._current_line_layer()
        combos = [getattr(self, name) for name in ('cmbP1Elev', 'cmbP2Elev', 'cmbP1H', 'cmbP2H') if hasattr(self, name)]
        for cb in combos:
            cb.blockSignals(True)
            cb.clear()
        if lyr is not None:
            try:
                for f in lyr.fields():
                    if f.isNumeric():
                        for cb in combos:
                            cb.addItem(f.name(), f.name())
                # Select defaults if present
                defaults = {
                    'cmbP1Elev': 'p1_elev',
                    'cmbP2Elev': 'p2_elev',
                    'cmbP1H': 'p1_h',
                    'cmbP2H': 'p2_h',
                }
                for name, def_field in defaults.items():
                    if hasattr(self, name):
                        cb = getattr(self, name)
                        idx = cb.findData(def_field)
                        if idx >= 0:
                            cb.setCurrentIndex(idx)
            except Exception:
                pass
        for cb in combos:
            cb.blockSignals(False)

    def _on_line_layer_changed(self, idx: int):
        self._populate_numeric_fields()
        self._push_gate_layer_to_floater()
        self._save_project_config()

        # Handle attribute creation button
        if hasattr(self, 'btnCreateDefaultAttrs'):
            self.btnCreateDefaultAttrs.clicked.connect(self._on_create_default_attrs)
        
        # Monitor selection changes for recalculate button
        self._connect_selection_monitoring()
        
        # Initialize change management system
        self._initialize_change_management()

    def _push_gate_layer_to_floater(self):
        if not self._floater:
            return
        try:
            lyr = self._current_line_layer()
            self._floater.set_gate_line_layer(lyr)
            # Measurement CRS follows vector layer CRS
            if lyr is not None and lyr.crs().isValid():
                self._floater.set_measure_crs(lyr.crs())
        except Exception:
            pass

    def _on_create_default_attrs(self):
        lyr = self._current_line_layer()
        if lyr is None:
            return
        required = ['p1_elev', 'p2_elev', 'p1_h', 'p2_h']
        existing = set([f.name() for f in lyr.fields()])
        if all(name in existing for name in required):
            # Warn already exists
            try:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("Default attributes already exist in the selected layer."))
            except Exception:
                pass
            # still reflect selection
            self._populate_numeric_fields()
            return
        # Add missing numeric fields (double)
        try:
            from qgis.PyQt.QtCore import QVariant
        except Exception:
            QVariant = None
        try:
            caps = lyr.dataProvider().capabilities()
            if not lyr.isEditable():
                lyr.startEditing()
            from qgis.core import QgsField
            for name in required:
                if name not in existing:
                    fld = QgsField(name, 6)  # QVariant.Double == 6 in many builds
                    lyr.addAttribute(fld)
            lyr.updateFields()
            lyr.commitChanges()
        except Exception:
            try:
                lyr.rollback()
            except Exception:
                pass
        # refresh selectors
        self._populate_numeric_fields()

    def _resolve_field_index(self, layer, ui_name: str, default_name: str) -> int:
        """Resolve field index from UI combo or default name"""
        try:
            if hasattr(self, ui_name):
                cb = getattr(self, ui_name)
                name = cb.currentData() if cb.currentIndex() >= 0 else default_name
            else:
                name = default_name
            return layer.fields().indexOf(name)
        except Exception:
            return -1

    # --- Display style handling -----------------------------------------------
    def _init_color_buttons(self):
        # Create color buttons in containers
        self.btnTextColor = None
        self.btnBgColor = None
        if hasattr(self, 'textColorContainer') and self.textColorContainer is not None:
            lay = QtWidgets.QHBoxLayout(self.textColorContainer)
            lay.setContentsMargins(0, 0, 0, 0)
            self.btnTextColor = QgsColorButton(self.textColorContainer)
            self.btnTextColor.setAllowOpacity(True)
            self.btnTextColor.setColor(QtGui.QColor(34, 34, 34, 255))
            self.btnTextColor.colorChanged.connect(self._on_style_changed)
            lay.addWidget(self.btnTextColor)
        if hasattr(self, 'bgColorContainer') and self.bgColorContainer is not None:
            lay2 = QtWidgets.QHBoxLayout(self.bgColorContainer)
            lay2.setContentsMargins(0, 0, 0, 0)
            self.btnBgColor = QgsColorButton(self.bgColorContainer)
            self.btnBgColor.setAllowOpacity(True)
            self.btnBgColor.setColor(QtGui.QColor(240, 240, 240, 200))
            self.btnBgColor.colorChanged.connect(self._on_style_changed)
            lay2.addWidget(self.btnBgColor)

    def _on_style_changed(self, *args):
        self._push_style_to_floater()
        self._save_project_config()

    def _push_style_to_floater(self):
        if not self._floater:
            return
        try:
            font = self.fontCombo.currentFont() if hasattr(self, 'fontCombo') else QtGui.QFont()
            size = int(self.spnFontSize.value()) if hasattr(self, 'spnFontSize') else 11
            bold_labels = bool(self.chkBoldLabels.isChecked()) if hasattr(self, 'chkBoldLabels') else True
            text_color = self.btnTextColor.color() if self.btnTextColor else QtGui.QColor(34, 34, 34)
            bg_color = self.btnBgColor.color() if self.btnBgColor else QtGui.QColor(240, 240, 240)
            layout_mode = 'vertical'
            if hasattr(self, 'cmbLabelLayout') and self.cmbLabelLayout.currentIndex() == 1:
                layout_mode = 'horizontal'
            corner = float(self.spnCornerRadius.value()) if hasattr(self, 'spnCornerRadius') else 3.5
            offx = int(self.spnOffsetX.value()) if hasattr(self, 'spnOffsetX') else 14
            offy = int(self.spnOffsetY.value()) if hasattr(self, 'spnOffsetY') else 10
            self._floater.set_style(font, size, text_color, bg_color, bold_labels)
            self._floater.set_layout_mode(layout_mode)
            self._floater.set_bubble_style(corner_radius=corner, offset_x=offx, offset_y=offy)
        except Exception:
            pass

    def _on_restore_default_style(self):
        try:
            # Defaults
            default_font = QtGui.QFont('Calibri')
            default_size = 11
            default_bold = True
            default_text = QtGui.QColor(34, 34, 34, 255)
            default_bg = QtGui.QColor(240, 240, 240, 200)
            default_layout = 'Vertical'
            default_corner = 3.5
            default_offx = 14
            default_offy = 10

            if hasattr(self, 'fontCombo'):
                self.fontCombo.setCurrentFont(default_font)
            if hasattr(self, 'spnFontSize'):
                self.spnFontSize.setValue(default_size)
            if hasattr(self, 'chkBoldLabels'):
                self.chkBoldLabels.setChecked(default_bold)
            if hasattr(self, 'btnTextColor') and self.btnTextColor:
                try:
                    self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnTextColor.setColor(default_text)
                self.btnTextColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'btnBgColor') and self.btnBgColor:
                try:
                    self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnBgColor.setColor(default_bg)
                self.btnBgColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'cmbLabelLayout'):
                idx = self.cmbLabelLayout.findText(default_layout)
                if idx >= 0:
                    self.cmbLabelLayout.setCurrentIndex(idx)
            if hasattr(self, 'spnCornerRadius'):
                self.spnCornerRadius.setValue(default_corner)
            if hasattr(self, 'spnOffsetX'):
                self.spnOffsetX.setValue(default_offx)
            if hasattr(self, 'spnOffsetY'):
                self.spnOffsetY.setValue(default_offy)

            # Apply and persist
            self._push_style_to_floater()
            self._save_project_config()
        except Exception:
            pass

    # Project Configuration Save/Load ----------------------------------------
    def _load_project_config(self):
        """Load plugin configuration from QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Load the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                estimate_enabled, ok = project.readBoolEntry(plugin_group, "estimate_enabled", False)
                if ok:
                    self.chkEstimateDepth.setChecked(estimate_enabled)
            
            # Load DEM layer and band
            dem_layer_id, ok = project.readEntry(plugin_group, "dem_layer_id", "")
            if ok and dem_layer_id:
                # Find layer by ID and select it
                layer = QgsProject.instance().mapLayer(dem_layer_id)
                if layer and hasattr(self, 'cmbDemLayer'):
                    for i in range(self.cmbDemLayer.count()):
                        if self.cmbDemLayer.itemData(i) == dem_layer_id:
                            self.cmbDemLayer.setCurrentIndex(i)
                            break
            
            # Load DEM band
            dem_band, ok = project.readNumEntry(plugin_group, "dem_band", 1)
            if ok and hasattr(self, 'cmbDemBand'):
                for i in range(self.cmbDemBand.count()):
                    if self.cmbDemBand.itemData(i) == dem_band:
                        self.cmbDemBand.setCurrentIndex(i)
                        break
            
            # Load sewer vector layer
            sewer_layer_id, ok = project.readEntry(plugin_group, "sewer_layer_id", "")
            if ok and sewer_layer_id:
                layer = QgsProject.instance().mapLayer(sewer_layer_id)
                if layer and hasattr(self, 'cmbLineLayer'):
                    for i in range(self.cmbLineLayer.count()):
                        if self.cmbLineLayer.itemData(i) == sewer_layer_id:
                            self.cmbLineLayer.setCurrentIndex(i)
                            break
            
            # Load parameters
            if hasattr(self, 'spnMinCover'):
                min_cover, ok = project.readDoubleEntry(plugin_group, "min_cover", 0.9)
                if ok:
                    self.spnMinCover.setValue(min_cover)
            
            if hasattr(self, 'spnDiameter'):
                diameter, ok = project.readNumEntry(plugin_group, "diameter_mm", 150)
                if ok:
                    self.spnDiameter.setValue(diameter)
            
            if hasattr(self, 'spnSlope'):
                slope, ok = project.readDoubleEntry(plugin_group, "slope", 0.005)
                if ok:
                    self.spnSlope.setValue(slope)
            
            if hasattr(self, 'spnInitialDepth'):
                initial_depth, ok = project.readDoubleEntry(plugin_group, "initial_depth", 0.0)
                if ok:
                    self.spnInitialDepth.setValue(initial_depth)
            
            # Load display settings
            if hasattr(self, 'chkShowExt'):
                show_ext, ok = project.readBoolEntry(plugin_group, "show_extension", True)
                if ok:
                    self.chkShowExt.setChecked(show_ext)
            
            if hasattr(self, 'chkShowElev'):
                show_elev, ok = project.readBoolEntry(plugin_group, "show_elevation", True)
                if ok:
                    self.chkShowElev.setChecked(show_elev)
            
            if hasattr(self, 'chkShowDepth'):
                show_depth, ok = project.readBoolEntry(plugin_group, "show_depth", True)
                if ok:
                    self.chkShowDepth.setChecked(show_depth)
            
            # Load style settings
            if hasattr(self, 'spnFontSize'):
                font_size, ok = project.readNumEntry(plugin_group, "font_size", 9)
                if ok:
                    self.spnFontSize.setValue(font_size)
            
            if hasattr(self, 'chkBoldLabels'):
                bold_labels, ok = project.readBoolEntry(plugin_group, "bold_labels", True)
                if ok:
                    self.chkBoldLabels.setChecked(bold_labels)
            
            # Load font family
            if hasattr(self, 'fontCombo'):
                font_family, ok = project.readEntry(plugin_group, "font_family", "")
                if ok and font_family:
                    try:
                        f = QtGui.QFont()
                        f.setFamily(font_family)
                        self.fontCombo.setCurrentFont(f)
                    except Exception:
                        pass

            # Load text and background colors (stored as r,g,b,a)
            try:
                text_color_str, ok = project.readEntry(plugin_group, "text_color_rgba", "")
                if ok and text_color_str and hasattr(self, 'btnTextColor') and self.btnTextColor:
                    parts = [int(p) for p in text_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnTextColor.setColor(color)
                        # Reconnect signal
                        self.btnTextColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            try:
                bg_color_str, ok = project.readEntry(plugin_group, "bg_color_rgba", "")
                if ok and bg_color_str and hasattr(self, 'btnBgColor') and self.btnBgColor:
                    parts = [int(p) for p in bg_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnBgColor.setColor(color)
                        # Reconnect signal
                        self.btnBgColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                layout_mode, ok = project.readEntry(plugin_group, "label_layout", "Vertical")
                if ok:
                    index = self.cmbLabelLayout.findText(layout_mode)
                    if index >= 0:
                        self.cmbLabelLayout.setCurrentIndex(index)
            
            if hasattr(self, 'spnCornerRadius'):
                corner_radius, ok = project.readDoubleEntry(plugin_group, "corner_radius", 3.5)
                if ok:
                    self.spnCornerRadius.setValue(corner_radius)
            
            if hasattr(self, 'spnOffsetX'):
                offset_x, ok = project.readNumEntry(plugin_group, "offset_x", 14)
                if ok:
                    self.spnOffsetX.setValue(offset_x)
            
            if hasattr(self, 'spnOffsetY'):
                offset_y, ok = project.readNumEntry(plugin_group, "offset_y", 10)
                if ok:
                    self.spnOffsetY.setValue(offset_y)
            
            # Ensure attribute combos are populated for the restored layer
            try:
                self._populate_numeric_fields()
                self._push_gate_layer_to_floater()
                # Ensure floater style reflects restored settings
                self._push_style_to_floater()
                # IMPORTANT: Restart floater with the restored DEM settings
                # This ensures the interpolator is initialized with the correct DEM
                if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
                    self._restart_floater()
            except Exception:
                pass

            # 
            #             print("[SEWERAGE DEBUG] Loaded project configuration")
            
        except Exception as e:
            # print(f"[SEWERAGE DEBUG] Error loading project config: {e}")
            pass
    
    def _save_project_config(self):
        """Save plugin configuration to QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Save the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                project.writeEntry(plugin_group, "estimate_enabled", str(self.chkEstimateDepth.isChecked()))
            
            # Save DEM layer and band
            if hasattr(self, 'cmbDemLayer') and self.cmbDemLayer.currentIndex() >= 0:
                dem_layer_id = self.cmbDemLayer.currentData()
                if dem_layer_id:
                    project.writeEntry(plugin_group, "dem_layer_id", dem_layer_id)
            
            if hasattr(self, 'cmbDemBand') and self.cmbDemBand.currentIndex() >= 0:
                dem_band = self.cmbDemBand.currentData()
                if dem_band is not None:
                    project.writeEntry(plugin_group, "dem_band", str(dem_band))
            
            # Save sewer vector layer
            if hasattr(self, 'cmbLineLayer') and self.cmbLineLayer.currentIndex() >= 0:
                sewer_layer_id = self.cmbLineLayer.currentData()
                if sewer_layer_id:
                    project.writeEntry(plugin_group, "sewer_layer_id", sewer_layer_id)
            
            # Save parameters
            if hasattr(self, 'spnMinCover'):
                project.writeEntry(plugin_group, "min_cover", str(self.spnMinCover.value()))
            
            if hasattr(self, 'spnDiameter'):
                project.writeEntry(plugin_group, "diameter_mm", str(self.spnDiameter.value()))
            
            if hasattr(self, 'spnSlope'):
                project.writeEntry(plugin_group, "slope", str(self.spnSlope.value()))
            
            if hasattr(self, 'spnInitialDepth'):
                project.writeEntry(plugin_group, "initial_depth", str(self.spnInitialDepth.value()))
            
            # Save display settings
            if hasattr(self, 'chkShowExt'):
                project.writeEntry(plugin_group, "show_extension", str(self.chkShowExt.isChecked()))
            
            if hasattr(self, 'chkShowElev'):
                project.writeEntry(plugin_group, "show_elevation", str(self.chkShowElev.isChecked()))
            
            if hasattr(self, 'chkShowDepth'):
                project.writeEntry(plugin_group, "show_depth", str(self.chkShowDepth.isChecked()))
            
            # Save style settings
            if hasattr(self, 'spnFontSize'):
                project.writeEntry(plugin_group, "font_size", str(self.spnFontSize.value()))
            
            if hasattr(self, 'chkBoldLabels'):
                project.writeEntry(plugin_group, "bold_labels", str(self.chkBoldLabels.isChecked()))
            
            # Save font family
            if hasattr(self, 'fontCombo'):
                try:
                    project.writeEntry(plugin_group, "font_family", self.fontCombo.currentFont().family())
                except Exception:
                    pass

            # Save colors as r,g,b,a
            try:
                if hasattr(self, 'btnTextColor') and self.btnTextColor:
                    c = self.btnTextColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "text_color_rgba", color_str)
            except Exception:
                pass

            try:
                if hasattr(self, 'btnBgColor') and self.btnBgColor:
                    c = self.btnBgColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "bg_color_rgba", color_str)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                project.writeEntry(plugin_group, "label_layout", self.cmbLabelLayout.currentText())
            
            if hasattr(self, 'spnCornerRadius'):
                project.writeEntry(plugin_group, "corner_radius", str(self.spnCornerRadius.value()))
            
            if hasattr(self, 'spnOffsetX'):
                project.writeEntry(plugin_group, "offset_x", str(self.spnOffsetX.value()))
            
            if hasattr(self, 'spnOffsetY'):
                project.writeEntry(plugin_group, "offset_y", str(self.spnOffsetY.value()))
            
            #             
            #             print("[SEWERAGE DEBUG] Saved project configuration")
            
        except Exception as e:
            # print(f"[SEWERAGE DEBUG] Error saving project config: {e}")
            pass

    def _connect_selection_monitoring(self):
        """Connect selection change monitoring for current line layer"""
        try:
            #             print("[SEWERAGE DEBUG] Setting up selection monitoring...")
            
            # Disconnect previous connections
            if hasattr(self, '_current_monitored_layer') and self._current_monitored_layer:
                try:
                    self._current_monitored_layer.selectionChanged.disconnect(self._on_selection_changed)
                    #                     print(f"[SEWERAGE DEBUG] Disconnected from previous layer: {self._current_monitored_layer.name()}")
                except:
                    pass
            
            # Connect to current layer
            layer = self._current_line_layer()
            if layer:
                layer.selectionChanged.connect(self._on_selection_changed)
                self._current_monitored_layer = layer
                #                 print(f"[SEWERAGE DEBUG] Connected selection monitoring to layer: {layer.name()}")
                # Update button state immediately
                self._on_selection_changed()
            else:
                self._current_monitored_layer = None
                self._update_recalculate_button_state(False)
                #                 print("[SEWERAGE DEBUG] No line layer available for selection monitoring")
        except Exception as e:
            pass
            #             print(f"[SEWERAGE DEBUG] Error connecting selection monitoring: {e}")

    def _on_selection_changed(self):
        """Update recalculate button state based on selection"""
        try:
            layer = self._current_line_layer()
            if layer:
                selected_count = len(layer.selectedFeatures())
                has_selection = selected_count > 0
                #                 print(f"[SEWERAGE DEBUG] Selection changed: {selected_count} features selected in {layer.name()}")
                self._update_recalculate_button_state(has_selection)
            else:
                #                 print("[SEWERAGE DEBUG] Selection changed but no layer available")
                self._update_recalculate_button_state(False)
        except Exception as e:
            pass
            #             print(f"[SEWERAGE DEBUG] Error in selection changed: {e}")

    def _update_recalculate_button_state(self, enabled: bool):
        """Enable/disable recalculate button"""
        if hasattr(self, 'btnRecalculateSelected'):
            self.btnRecalculateSelected.setEnabled(enabled)
            #             print(f"[SEWERAGE DEBUG] Recalculate button enabled: {enabled}")
        else:
            # print("[SEWERAGE DEBUG] btnRecalculateSelected not found!")
            pass

    def _on_recalculate_selected(self):
        """Recalculate depths for selected segments"""
        try:
            #             print("[SEWERAGE DEBUG] Starting recalculation of selected segments...")
            
            layer = self._current_line_layer()
            if not layer:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No line layer selected")
                return
            
            selected_features = layer.selectedFeatures()
            if not selected_features:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No features selected")
                return

            # 
            #             print(f"[SEWERAGE DEBUG] Processing {len(selected_features)} selected features")

            # Get current parameters
            min_cover = self.spnMinCover.value() if hasattr(self, 'spnMinCover') else 0.9
            diameter = self.spnDiameter.value() / 1000.0 if hasattr(self, 'spnDiameter') else 0.15  # Convert mm to m
            slope = self.spnSlope.value() if hasattr(self, 'spnSlope') else 0.005
            initial_depth = self.spnInitialDepth.value() if hasattr(self, 'spnInitialDepth') else 0.0

            # 
            #             print(f"[SEWERAGE DEBUG] Parameters - min_cover: {min_cover}m, diameter: {diameter}m, slope: {slope}, initial_depth: {initial_depth}m")

            # Get DEM layer for elevation interpolation
            dem_layer = self._current_dem_layer()
            if not dem_layer:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No DEM layer selected")
                return

            # 
            #             print(f"[SEWERAGE DEBUG] Using DEM layer: {dem_layer.name()}")

            # Start editing if needed
            if not layer.isEditable():
                layer.startEditing()

            # Clear existing depths and interpolate missing elevations
            self._prepare_selected_features(selected_features, layer, dem_layer)

            # Calculate depths using tree algorithm
            self._calculate_tree_depths(selected_features, layer, dem_layer, min_cover, diameter, slope, initial_depth)

            if self.iface:
                self.iface.messageBar().pushSuccess("Sewerage Depth Estimator", 
                                                   f"Recalculated depths for {len(selected_features)} segments")

        except Exception as e:
            #             print(f"[SEWERAGE DEBUG] Error in recalculate selected: {e}")
            if self.iface:
                self.iface.messageBar().pushCritical("Sewerage Depth Estimator", f"Error: {str(e)}")

    def _on_apply_style(self):
        """Apply default QML style to the selected segment layer"""
        import os
        try:
            layer = self._current_line_layer()
            if not layer:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No line layer selected")
                return
            
            # Get path to the QML style file
            plugin_dir = os.path.dirname(__file__)
            style_path = os.path.join(plugin_dir, "style", "default_segment_style.qml")
            
            if not os.path.exists(style_path):
                if self.iface:
                    self.iface.messageBar().pushCritical("Sewerage Depth Estimator", 
                                                        f"Style file not found: {style_path}")
                return
            
            # Apply the style to the layer
            # loadNamedStyle returns (error_message, success_flag)
            result = layer.loadNamedStyle(style_path)
            
            # Check if result is a tuple or just a boolean
            if isinstance(result, tuple):
                error_msg, success = result
                if not success:
                    if self.iface:
                        self.iface.messageBar().pushCritical("Sewerage Depth Estimator", 
                                                            f"Failed to apply style: {error_msg if error_msg else 'Unknown error'}")
                    return
            else:
                # Some QGIS versions might return just a boolean
                if not result:
                    if self.iface:
                        self.iface.messageBar().pushCritical("Sewerage Depth Estimator", 
                                                            "Failed to apply style: Unknown error")
                    return
            
            # Refresh layer to show style changes
            layer.triggerRepaint()
            if self.iface:
                self.iface.messageBar().pushSuccess("Sewerage Depth Estimator", 
                                                   f"Style applied successfully to layer '{layer.name()}'")
                    
        except Exception as e:
            if self.iface:
                self.iface.messageBar().pushCritical("Sewerage Depth Estimator", f"Error applying style: {str(e)}")

    def _prepare_selected_features(self, selected_features, layer, dem_layer):
        """Clear depths and interpolate missing elevations for selected features"""
        from .elevation_floater import RasterInterpolator
        from qgis.core import QgsCoordinateTransform, QgsProject, QgsPointXY
        
        #         
        #         print("[SEWERAGE DEBUG] Preparing selected features - clearing depths and interpolating elevations...")
        
        # Get field indices
        field_mapping = self._get_field_mapping(layer)
        p1_elev_idx = field_mapping.get('p1_elev', -1)
        p2_elev_idx = field_mapping.get('p2_elev', -1)
        p1_h_idx = field_mapping.get('p1_h', -1)
        p2_h_idx = field_mapping.get('p2_h', -1)

        # 
        #         print(f"[SEWERAGE DEBUG] Field mapping: p1_elev={p1_elev_idx}, p2_elev={p2_elev_idx}, p1_h={p1_h_idx}, p2_h={p2_h_idx}")

        # Setup raster interpolator
        interpolator = RasterInterpolator(dem_layer, band=1)
        transform_context = QgsProject.instance().transformContext()
        to_raster = QgsCoordinateTransform(layer.crs(), dem_layer.crs(), transform_context)

        for feature in selected_features:
            try:
                #                 print(f"[SEWERAGE DEBUG] Processing feature ID {feature.id()}")
                
                # Clear existing depths
                if p1_h_idx >= 0:
                    layer.changeAttributeValue(feature.id(), p1_h_idx, None)
                    #                     print(f"[SEWERAGE DEBUG]   Cleared p1_h for feature {feature.id()}")
                if p2_h_idx >= 0:
                    layer.changeAttributeValue(feature.id(), p2_h_idx, None)
                    #                     print(f"[SEWERAGE DEBUG]   Cleared p2_h for feature {feature.id()}")

                # Get geometry endpoints
                geom = feature.geometry()
                if geom.isEmpty():
                    #                     print(f"[SEWERAGE DEBUG]   Feature {feature.id()} has empty geometry, skipping")
                    continue
                
                if geom.isMultipart():
                    lines = geom.asMultiPolyline()
                    if not lines:
                        #                         print(f"[SEWERAGE DEBUG]   Feature {feature.id()} has no lines, skipping")
                        continue
                    pts = lines[0]
                else:
                    pts = geom.asPolyline()
                
                if len(pts) < 2:
                    #                     print(f"[SEWERAGE DEBUG]   Feature {feature.id()} has less than 2 points, skipping")
                    continue

                p1, p2 = QgsPointXY(pts[0]), QgsPointXY(pts[-1])
                #                 print(f"[SEWERAGE DEBUG]   Feature {feature.id()} endpoints: P1({p1.x():.2f}, {p1.y():.2f}) -> P2({p2.x():.2f}, {p2.y():.2f})")

                # Interpolate missing elevations
                if p1_elev_idx >= 0:
                    p1_elev = feature.attribute(p1_elev_idx)
                    if p1_elev is None or p1_elev == '':
                        try:
                            p1_raster = to_raster.transform(p1)
                            elev = interpolator.bilinear(p1_raster)
                            if elev is not None:
                                layer.changeAttributeValue(feature.id(), p1_elev_idx, round(float(elev), 2))
                                #                                 print(f"[SEWERAGE DEBUG]   Interpolated P1 elevation: {round(float(elev), 2)}m")
                            else:
                                # print(f"[SEWERAGE DEBUG]   Failed to interpolate P1 elevation")
                                pass
                        except Exception as ex:
                            pass
                            #                             print(f"[SEWERAGE DEBUG]   Error interpolating P1 elevation: {ex}")
                    else:
                        # print(f"[SEWERAGE DEBUG]   P1 elevation already exists: {p1_elev}m")
                        pass

                if p2_elev_idx >= 0:
                    p2_elev = feature.attribute(p2_elev_idx)
                    if p2_elev is None or p2_elev == '':
                        try:
                            p2_raster = to_raster.transform(p2)
                            elev = interpolator.bilinear(p2_raster)
                            if elev is not None:
                                layer.changeAttributeValue(feature.id(), p2_elev_idx, round(float(elev), 2))
                                #                                 print(f"[SEWERAGE DEBUG]   Interpolated P2 elevation: {round(float(elev), 2)}m")
                            else:
                                pass
                                #                                 print(f"[SEWERAGE DEBUG]   Failed to interpolate P2 elevation")
                        except Exception as ex:
                            pass
                            #                             print(f"[SEWERAGE DEBUG]   Error interpolating P2 elevation: {ex}")
                    else:
                        pass
                        #                         print(f"[SEWERAGE DEBUG]   P2 elevation already exists: {p2_elev}m")

            except Exception as e:
                pass
                #                 print(f"[SEWERAGE DEBUG] Error preparing feature {feature.id()}: {e}")

    def _calculate_tree_depths(self, selected_features, layer, dem_layer, min_cover, diameter, slope, initial_depth):
        """Calculate depths using tree traversal algorithm for open sewerage networks"""
        from qgis.core import QgsPointXY
        
        #         
        #         print("[SEWERAGE DEBUG] Starting tree depth calculation...")
        
        # Get field indices
        field_mapping = self._get_field_mapping(layer)
        p1_elev_idx = field_mapping.get('p1_elev', -1)
        p2_elev_idx = field_mapping.get('p2_elev', -1)
        p1_h_idx = field_mapping.get('p1_h', -1)
        p2_h_idx = field_mapping.get('p2_h', -1)

        if min(p1_elev_idx, p2_elev_idx, p1_h_idx, p2_h_idx) < 0:
            raise Exception("Missing required elevation or depth fields")

        # Build network topology
        segments = []
        node_connections = {}  # node_key -> list of (segment_idx, is_upstream)

        def node_key(pt: QgsPointXY) -> str:
            return f"{pt.x():.6f},{pt.y():.6f}"

        # 
        #         print("[SEWERAGE DEBUG] Building network topology...")

        # Extract segments and build topology
        for i, feature in enumerate(selected_features):
            geom = feature.geometry()
            if geom.isEmpty():
                #                 print(f"[SEWERAGE DEBUG]   Skipping feature {feature.id()}: empty geometry")
                continue
                
            if geom.isMultipart():
                lines = geom.asMultiPolyline()
                if not lines:
                    #                     print(f"[SEWERAGE DEBUG]   Skipping feature {feature.id()}: no lines")
                    continue
                pts = lines[0]
            else:
                pts = geom.asPolyline()
            
            if len(pts) < 2:
                #                 print(f"[SEWERAGE DEBUG]   Skipping feature {feature.id()}: less than 2 points")
                continue

            p1, p2 = QgsPointXY(pts[0]), QgsPointXY(pts[-1])
            
            # Get elevations
            p1_elev = feature.attribute(p1_elev_idx)
            p2_elev = feature.attribute(p2_elev_idx)
            
            try:
                p1_elev = float(p1_elev) if p1_elev not in (None, '') else None
                p2_elev = float(p2_elev) if p2_elev not in (None, '') else None
            except:
                #                 print(f"[SEWERAGE DEBUG]   Skipping feature {feature.id()}: invalid elevation values")
                continue

            if p1_elev is None or p2_elev is None:
                #                 print(f"[SEWERAGE DEBUG]   Feature {feature.id()} missing elevations (p1={p1_elev}, p2={p2_elev}) - trying to interpolate now...")
                
                # Try to interpolate missing elevations on the fly
                try:
                    from .elevation_floater import RasterInterpolator
                    from qgis.core import QgsCoordinateTransform, QgsProject
                    
                    interpolator_temp = RasterInterpolator(dem_layer, band=1)
                    transform_context = QgsProject.instance().transformContext()
                    to_raster_temp = QgsCoordinateTransform(layer.crs(), dem_layer.crs(), transform_context)
                except Exception as ex:
                    #                     print(f"[SEWERAGE DEBUG]   Error setting up interpolator: {ex}, skipping feature {feature.id()}")
                    continue
                
                # Try to interpolate missing values
                if p1_elev is None and p1_elev_idx >= 0:
                    try:
                        p1_raster = to_raster_temp.transform(p1)
                        elev = interpolator_temp.bilinear(p1_raster)
                        if elev is not None:
                            p1_elev = round(float(elev), 2)
                            layer.changeAttributeValue(feature.id(), p1_elev_idx, p1_elev)
                            #                             print(f"[SEWERAGE DEBUG]   Interpolated P1 elevation on-the-fly: {p1_elev}m")
                    except Exception as ex:
                        pass
                        #                         print(f"[SEWERAGE DEBUG]   Error interpolating P1: {ex}")
                
                if p2_elev is None and p2_elev_idx >= 0:
                    try:
                        p2_raster = to_raster_temp.transform(p2)
                        elev = interpolator_temp.bilinear(p2_raster)
                        if elev is not None:
                            p2_elev = round(float(elev), 2)
                            layer.changeAttributeValue(feature.id(), p2_elev_idx, p2_elev)
                            #                             print(f"[SEWERAGE DEBUG]   Interpolated P2 elevation on-the-fly: {p2_elev}m")
                    except Exception as ex:
                        pass
                        #                         print(f"[SEWERAGE DEBUG]   Error interpolating P2: {ex}")
                
                # Check again if we have elevations now
                if p1_elev is None or p2_elev is None:
                    #                     print(f"[SEWERAGE DEBUG]   Still missing elevations after interpolation attempt, skipping feature {feature.id()}")
                    continue

            # Calculate segment length
            seg_length = ((p2.x() - p1.x()) ** 2 + (p2.y() - p1.y()) ** 2) ** 0.5

            # 
            #             print(f"[SEWERAGE DEBUG]   Added segment {i}: Feature {feature.id()}, length={seg_length:.2f}m, elevations: P1={p1_elev}m, P2={p2_elev}m")

            segment_data = {
                'feature': feature,
                'p1': p1,
                'p2': p2,
                'p1_elev': p1_elev,
                'p2_elev': p2_elev,
                'length': seg_length,
                'processed': False
            }
            segments.append(segment_data)

            # Update topology
            p1_key = node_key(p1)
            p2_key = node_key(p2)
            
            node_connections.setdefault(p1_key, []).append((i, True))   # p1 is upstream
            node_connections.setdefault(p2_key, []).append((i, False))  # p2 is downstream

        # Find root segments (no upstream connections)
        roots = []
        for i, seg in enumerate(segments):
            p1_key = node_key(seg['p1'])
            has_upstream = any(not is_upstream for _, is_upstream in node_connections.get(p1_key, []))
            if not has_upstream:
                roots.append(i)
                #                 print(f"[SEWERAGE DEBUG]   Root segment {i}: Feature {seg['feature'].id()}")

        # 
        #         print(f"[SEWERAGE DEBUG] Found {len(roots)} root segments from {len(segments)} total")

        # Process network with multiple iterations to handle convergent flows
        self._process_convergent_network(segments, node_connections, layer, dem_layer,
                                        min_cover, diameter, slope, initial_depth,
                                        p1_h_idx, p2_h_idx)

    def _process_convergent_network(self, segments, node_connections, layer, dem_layer,
                                   min_cover, diameter, slope, initial_depth,
                                   p1_h_idx, p2_h_idx):
        """Process network from root segments downstream, resolving convergent vertices with maximum depth"""
        def node_key(pt):
            return f"{pt.x():.6f},{pt.y():.6f}"
        
        #         
        #         print("[SEWERAGE DEBUG] Starting root-to-outlet processing with convergent vertex resolution...")
        
        # Find root segments (no upstream connections) - these are starting points
        root_segments = []
        for seg_idx, segment in enumerate(segments):
            p1_key = node_key(segment['p1'])
            has_upstream = any(not is_upstream for _, is_upstream in node_connections.get(p1_key, []))
            if not has_upstream:
                root_segments.append(seg_idx)
                #                 print(f"[SEWERAGE DEBUG] Root segment {seg_idx} (Feature {segment['feature'].id()}) - starting point")
        
        # Find outlet segments (no downstream connections) - these define where to stop
        outlet_segments = []
        for seg_idx, segment in enumerate(segments):
            p2_key = node_key(segment['p2'])
            has_downstream = any(is_upstream for _, is_upstream in node_connections.get(p2_key, []))
            if not has_downstream:
                outlet_segments.append(seg_idx)
                #                 print(f"[SEWERAGE DEBUG] Outlet segment {seg_idx} (Feature {segment['feature'].id()}) - endpoint")
        
        if not root_segments:
            #             print("[SEWERAGE DEBUG] ERROR: No root segments found!")
            return
        
        #         
        #         print(f"[SEWERAGE DEBUG] Found {len(root_segments)} root segments and {len(outlet_segments)} outlets")
        
        # Track computed depths at each vertex (taking maximum depth when multiple branches converge)
        vertex_depths = {}  # node_key -> max_depth
        segment_depths = {}  # seg_idx -> (p1_depth, p2_depth)
        
        # Process ALL segments in a unified manner, not separately per root
        #         print(f"[SEWERAGE DEBUG] Processing unified network from all {len(root_segments)} root segments")
        self._process_unified_network(root_segments, segments, node_connections, 
                                    vertex_depths, segment_depths, min_cover, diameter, slope, initial_depth)
        
        # Write final depths to features
        #         print("[SEWERAGE DEBUG] Writing final depths to features...")
        for seg_idx, (p1_depth, p2_depth) in segment_depths.items():
            feature = segments[seg_idx]['feature']
            layer.changeAttributeValue(feature.id(), p1_h_idx, round(p1_depth, 2))
            layer.changeAttributeValue(feature.id(), p2_h_idx, round(p2_depth, 2))
            #             print(f"[SEWERAGE DEBUG]   Final Feature {feature.id()}: P1_H={round(p1_depth, 2)}m, P2_H={round(p2_depth, 2)}m")

    def _process_unified_network(self, root_segments, segments, node_connections,
                               vertex_depths, segment_depths, min_cover, diameter, slope, initial_depth):
        """Process all segments in unified manner with proper convergent vertex handling"""
        def node_key(pt):
            return f"{pt.x():.6f},{pt.y():.6f}"
        
        # Initialize all root segments in queue
        queue = []
        processed = set()
        
        # Add all root segments to queue with their initial depths
        for root_seg_idx in root_segments:
            upstream_depth = max(initial_depth, min_cover + diameter) if initial_depth > 0 else min_cover + diameter
            segment = segments[root_seg_idx]
            p1_key = node_key(segment['p1'])
            vertex_depths[p1_key] = upstream_depth
            queue.append((root_seg_idx, upstream_depth))
            #             print(f"[SEWERAGE DEBUG] Added root segment {root_seg_idx} to queue with depth {upstream_depth:.2f}m")
        
        # Process segments until queue is empty
        while queue:
            seg_idx, upstream_depth = queue.pop(0)
            
            if seg_idx in processed:
                #                 print(f"[SEWERAGE DEBUG]   Segment {seg_idx} already processed, skipping")
                continue
                
            segment = segments[seg_idx]
            p1_key = node_key(segment['p1'])
            p2_key = node_key(segment['p2'])
            
            #             
            #             print(f"[SEWERAGE DEBUG]   Processing segment {seg_idx} (Feature {segment['feature'].id()}) with upstream depth {upstream_depth:.2f}m")
            
            # Calculate segment depths
            p1_depth, p2_depth = self._calculate_segment_depths(segment, upstream_depth, min_cover, diameter, slope)
            segment_depths[seg_idx] = (p1_depth, p2_depth)
            processed.add(seg_idx)
            
            #             
            #             print(f"[SEWERAGE DEBUG]     Calculated: {p1_depth:.2f}m -> {p2_depth:.2f}m")
            
            # Check downstream vertex for convergence
            self._handle_downstream_vertex(seg_idx, p2_key, p2_depth, segments, node_connections, 
                                         vertex_depths, segment_depths, queue, processed)

    def _handle_downstream_vertex(self, seg_idx, p2_key, p2_depth, segments, node_connections,
                                vertex_depths, segment_depths, queue, processed):
        """Handle downstream vertex - check for convergence and add appropriate segments to queue"""
        upstream_segments_to_p2 = [idx for idx, is_upstream in node_connections.get(p2_key, []) if not is_upstream]
        downstream_segments = [idx for idx, is_upstream in node_connections.get(p2_key, []) if is_upstream]
        
        #         
        #         print(f"[SEWERAGE DEBUG]     Vertex {p2_key}: {len(upstream_segments_to_p2)} upstream, {len(downstream_segments)} downstream")
        
        if len(upstream_segments_to_p2) > 1:
            # CONVERGENT VERTEX - check if ALL upstream segments are processed
            all_upstream_processed = all(us_idx in processed for us_idx in upstream_segments_to_p2)
            #             print(f"[SEWERAGE DEBUG]     CONVERGENT VERTEX: upstream segments {upstream_segments_to_p2}, all processed: {all_upstream_processed}")
            
            # Always update vertex depth with maximum from all processed upstream segments
            upstream_depths = []
            for us_idx in upstream_segments_to_p2:
                if us_idx in segment_depths:
                    us_p2_depth = segment_depths[us_idx][1]
                    upstream_depths.append((us_idx, us_p2_depth))
            
            if upstream_depths:
                max_depth = max(depth for _, depth in upstream_depths)
                vertex_depths[p2_key] = max_depth
                #                 print(f"[SEWERAGE DEBUG]     CONVERGENT VERTEX {p2_key}: Current MAX depth {max_depth:.2f}m from {upstream_depths}")
                
                if all_upstream_processed:
                    # All upstream processed - now we can proceed downstream
                    #                     print(f"[SEWERAGE DEBUG]     CONVERGENT VERTEX {p2_key}: RESOLVED with depth {max_depth:.2f}m")
                    for ds_idx in downstream_segments:
                        if ds_idx not in processed:
                            queue.append((ds_idx, max_depth))
                            #                             print(f"[SEWERAGE DEBUG]     Added downstream segment {ds_idx} with resolved depth {max_depth:.2f}m")
                else:
                    pass
                    #                     print(f"[SEWERAGE DEBUG]     CONVERGENT VERTEX {p2_key}: Waiting for more upstream segments")
        else:
            # NOT convergent - proceed normally
            vertex_depths[p2_key] = p2_depth
            
            if len(downstream_segments) == 0:
                # print(f"[SEWERAGE DEBUG]     Outlet reached: vertex {p2_key} depth = {p2_depth:.2f}m")
                pass
            else:
                #                 print(f"[SEWERAGE DEBUG]     Normal vertex {p2_key}: depth = {p2_depth:.2f}m")
                for ds_idx in downstream_segments:
                    if ds_idx not in processed:
                        queue.append((ds_idx, p2_depth))
                        #                         print(f"[SEWERAGE DEBUG]     Added downstream segment {ds_idx} with depth {p2_depth:.2f}m")

    def _calculate_segment_depths(self, segment, upstream_depth, min_cover, diameter, slope):
        """Calculate depths for a single segment"""
        p1_elev = segment['p1_elev']
        p2_elev = segment['p2_elev']
        elevation_diff = p1_elev - p2_elev
        
        # Calculate upstream bottom elevation (invert)
        upstream_bottom_elev = p1_elev - upstream_depth
        
        # Calculate required downstream bottom elevation based on slope
        fall = segment['length'] * slope
        downstream_bottom_elev = upstream_bottom_elev - fall
        
        # Calculate downstream depth from ground
        downstream_depth_candidate = p2_elev - downstream_bottom_elev
        
        # Enforce minimum cover at downstream
        min_downstream_depth = min_cover + diameter
        downstream_depth = max(downstream_depth_candidate, min_downstream_depth)
        
        # Calculate actual slope achieved
        actual_downstream_bottom = p2_elev - downstream_depth
        actual_fall = upstream_bottom_elev - actual_downstream_bottom
        actual_slope = actual_fall / segment['length'] if segment['length'] > 0 else 0
        
        #         
        #         print(f"[SEWERAGE DEBUG]     Terrain: P1={p1_elev:.2f}m, P2={p2_elev:.2f}m, diff={elevation_diff:.2f}m")
        #         print(f"[SEWERAGE DEBUG]     Upstream bottom: {upstream_bottom_elev:.2f}m, Target downstream: {downstream_bottom_elev:.2f}m")
        #         print(f"[SEWERAGE DEBUG]     Depth candidate: {downstream_depth_candidate:.2f}m, min_required: {min_downstream_depth:.2f}m")
        #         print(f"[SEWERAGE DEBUG]     Final depth: {downstream_depth:.2f}m, Actual slope: {actual_slope:.4f}")
        
        return upstream_depth, downstream_depth

    def _get_field_mapping(self, layer):
        """Get field mapping for the given layer"""
        try:
            p1e_idx = self._resolve_field_index(layer, 'cmbP1Elev', 'p1_elev')
            p2e_idx = self._resolve_field_index(layer, 'cmbP2Elev', 'p2_elev') 
            p1h_idx = self._resolve_field_index(layer, 'cmbP1H', 'p1_h')
            p2h_idx = self._resolve_field_index(layer, 'cmbP2H', 'p2_h')
            
            return {
                'p1_elev': p1e_idx,
                'p2_elev': p2e_idx,
                'p1_h': p1h_idx,
                'p2_h': p2h_idx
            }
        except:
            return {
                'p1_elev': layer.fields().indexOf('p1_elev'),
                'p2_elev': layer.fields().indexOf('p2_elev'),
                'p1_h': layer.fields().indexOf('p1_h'),
                'p2_h': layer.fields().indexOf('p2_h')
            }

    # --- Change Management System Integration -----------------------------------
    
    def _initialize_change_management(self):
        """Initialize or reinitialize the change management system when layers change."""
        try:
            vector_layer = self._current_line_layer()
            dem_layer = self._current_dem_layer()
            
            if vector_layer is None:
                #                 print("[SEWERAGE DEBUG] No vector layer available for change management")
                return
            
            # Initialize the change management system
            success = self._change_integration.initialize_change_management(vector_layer, dem_layer)
            
            if success:
                # Update current parameters
                self._update_change_management_parameters()
                
                # Start monitoring only if "Estimate depth" is enabled and we have both layers
                if dem_layer is not None and self._is_depth_estimation_enabled():
                    self._start_change_monitoring_if_available()
                    # print("[SEWERAGE DEBUG] Change management system started with automatic monitoring")
                else:
                    pass
                    # print("[SEWERAGE DEBUG] Change management initialized but not started (depth estimation disabled or no DEM)")
            else:
                pass
                # print("[SEWERAGE DEBUG] Failed to initialize change management system")
                
        except Exception as e:
            pass
            #             print(f"[SEWERAGE DEBUG] Error initializing change management: {e}")
    
    def _update_change_management_parameters(self):
        """Update change management system with current parameter values."""
        try:
            if not self._change_integration:
                return
                
            # Get current parameter values
            min_cover = self.spnMinCover.value() if hasattr(self, 'spnMinCover') else 0.9
            diameter = self.spnDiameter.value() if hasattr(self, 'spnDiameter') else 150.0  # mm
            slope = self.spnSlope.value() if hasattr(self, 'spnSlope') else 0.005
            
            # Update the change management system
            self._change_integration.update_calculation_parameters(
                min_cover_m=min_cover,
                diameter_m=diameter,  # This will be converted from mm to m in the integration layer
                slope_m_per_m=slope
            )
            
            #             
            #             print(f"[SEWERAGE DEBUG] Updated change management parameters: cover={min_cover}m, diameter={diameter}mm, slope={slope}")
            
        except Exception as e:
            pass
            #             print(f"[SEWERAGE DEBUG] Error updating change management parameters: {e}")
    
    def _on_params_changed_with_change_management(self, *args):
        """Handle parameter changes and update both floater and change management."""
        # Call original parameter change handler
        self._on_params_changed(*args)
        
        # Update change management parameters
        self._update_change_management_parameters()
    
    def get_change_management_status(self):
        """Get status of the change management system for debugging."""
        try:
            if not self._change_integration:
                return {"initialized": False}
                
            status = self._change_integration.get_system_status()
            status["vector_layer"] = self._current_line_layer().name() if self._current_line_layer() else None
            status["dem_layer"] = self._current_dem_layer().name() if self._current_dem_layer() else None
            
            return status
        except Exception as e:
            return {"error": str(e)}
    
    def manual_recalculate_all_depths(self):
        """Manually trigger full network recalculation using change management system."""
        try:
            if not self._change_integration:
                #                 print("[SEWERAGE DEBUG] Change management not initialized")
                return False
                
            stats = self._change_integration.manual_recalculate_network(selected_only=False)
            #             print(f"[SEWERAGE DEBUG] Manual recalculation complete: {stats}")
            
            if self.iface and 'error' not in stats:
                self.iface.messageBar().pushSuccess(
                    "Sewerage Depth Estimator",
                    f"Recalculated depths for network: {stats.get('recalculated', 0)} segments updated"
                )
            
            return 'error' not in stats
            
        except Exception as e:
            #             print(f"[SEWERAGE DEBUG] Error in manual recalculation: {e}")
            if self.iface:
                self.iface.messageBar().pushCritical(
                    "Sewerage Depth Estimator", 
                    f"Error in recalculation: {str(e)}"
                )
            return False
    
    def test_change_management_system(self):
        """Test method to verify change management system is working."""
        try:
            #             print("[SEWERAGE DEBUG] ===== TESTING ENHANCED CHANGE MANAGEMENT SYSTEM =====")
            
            # Get current status
            status = self.get_change_management_status()
            #             print(f"[SEWERAGE DEBUG] Current status: {status}")
            
            # Check if monitoring is active
            is_monitoring = self._change_integration.is_monitoring_active() if self._change_integration else False
            #             print(f"[SEWERAGE DEBUG] Enhanced monitoring active: {is_monitoring}")
            
            # Check layers
            vector_layer = self._current_line_layer()
            dem_layer = self._current_dem_layer()
            #             print(f"[SEWERAGE DEBUG] Vector layer: {vector_layer.name() if vector_layer else 'None'}")
            #             print(f"[SEWERAGE DEBUG] DEM layer: {dem_layer.name() if dem_layer else 'None'}")
            
            # Test enhanced system features
            if self._change_integration and hasattr(self._change_integration, 'enhanced_change_manager'):
                enhanced_manager = self._change_integration.enhanced_change_manager
                if enhanced_manager:
                    #                     print("[SEWERAGE DEBUG] Enhanced system features:")
                    network_stats = enhanced_manager.get_network_statistics()
                    #                     print(f"[SEWERAGE DEBUG]   - Network topology: {network_stats.get('network_topology', {})}")
                    #                     print(f"[SEWERAGE DEBUG]   - Processing stats: {network_stats.get('processing_stats', {})}")
                    #                     print(f"[SEWERAGE DEBUG]   - Elevation interpolation: {network_stats.get('elevation_interpolation_available', False)}")
            
            # If not monitoring but we have layers, try to start
            if not is_monitoring and vector_layer and dem_layer:
                #                 print("[SEWERAGE DEBUG] Attempting to restart enhanced change management...")
                self._initialize_change_management()
                
                new_status = self._change_integration.is_monitoring_active() if self._change_integration else False
                #                 print(f"[SEWERAGE DEBUG] Enhanced monitoring after restart: {new_status}")
            
            #             
            #             print("[SEWERAGE DEBUG] ===== ENHANCED TEST COMPLETE =====")
            
            return {
                'monitoring_active': is_monitoring,
                'has_vector_layer': vector_layer is not None,
                'has_dem_layer': dem_layer is not None,
                'enhanced_system': True,  # Always true now
                'status': status
            }
            
        except Exception as e:
            # print(f"[SEWERAGE DEBUG] Error in enhanced test: {e}")
            pass
    
    def _is_depth_estimation_enabled(self) -> bool:
        """Check if the "Estimate depth" checkbox is enabled."""
        return hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked()
    
    def _start_change_monitoring_if_available(self) -> bool:
        """Start change monitoring if change management is available and depth estimation is enabled."""
        if not self._change_integration or not self._is_depth_estimation_enabled():
            return False
        
        try:
            return self._change_integration.start_change_monitoring()
        except Exception as e:
            # print(f"[SEWERAGE DEBUG] Error starting change monitoring: {e}")
            return False
    
    def _stop_change_monitoring_if_available(self) -> bool:
        """Stop change monitoring if change management is available."""
        if not self._change_integration:
            return True
        
        try:
            return self._change_integration.stop_change_monitoring()
        except Exception as e:
            # print(f"[SEWERAGE DEBUG] Error stopping change monitoring: {e}")
            return False
            
        except Exception as e:
            #             print(f"[SEWERAGE DEBUG] Error in enhanced test: {e}")
            return {'error': str(e)}
