# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SewerageDepthEstimatorDockWidget
                                 A QGIS plugin
 Estimate the depth of sewer network based on simplified parameters
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-08
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonardo Nazareth
        email                : leonazareth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject, QgsMapLayer, QgsCoordinateReferenceSystem
try:
    from qgis.gui import QgsProjectionSelectionWidget
except Exception:  # pragma: no cover - optional in some envs
    QgsProjectionSelectionWidget = None
from qgis.gui import QgsColorButton

from .elevation_floater import ElevationFloaterController

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'sewerage_depth_estimator_dockwidget_base.ui'))


class SewerageDepthEstimatorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface=None, parent=None):
        """Constructor."""
        super(SewerageDepthEstimatorDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # QGIS iface and canvas
        self.iface = iface
        self.canvas = self.iface.mapCanvas() if self.iface else None

        # Elevation floater controller (non-intrusive, does not change active tool)
        self._floater = ElevationFloaterController(self.iface) if self.iface else None

        # Wire checkbox
        if hasattr(self, 'chkEstimateDepth'):
            self.chkEstimateDepth.toggled.connect(self._on_toggle_estimator)

        # Populate DEM layers and watch project changes
        self._populate_dem_layers()
        QgsProject.instance().layersAdded.connect(self._populate_dem_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_dem_layers)
        QgsProject.instance().layerWasAdded.connect(self._populate_dem_layers)
        # Populate vector line layers for Layers tab
        self._populate_line_layers()
        QgsProject.instance().layersAdded.connect(self._populate_line_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_line_layers)
        
        # Initialize color buttons BEFORE loading project config so they exist when colors are loaded
        self._init_color_buttons()
        
        # Load saved project configuration AFTER both DEM and Line layer combos and color buttons are ready
        # so that saved selections can be restored correctly.
        self._load_project_config()
        if hasattr(self, 'cmbLineLayer'):
            self.cmbLineLayer.currentIndexChanged.connect(self._on_line_layer_changed)
            self._push_gate_layer_to_floater()
            # Set up initial selection monitoring
            self._connect_selection_monitoring()
        if hasattr(self, 'cmbDemLayer'):
            self.cmbDemLayer.currentIndexChanged.connect(self._on_dem_layer_changed)
        # No CRS selection widget; measure CRS will follow the vector layer
        # Parameters wiring
        if hasattr(self, 'spnMinCover'):
            self.spnMinCover.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnDiameter'):
            self.spnDiameter.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnSlope'):
            self.spnSlope.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnInitialDepth'):
            self.spnInitialDepth.valueChanged.connect(self._on_params_changed)
        # Display toggles
        if hasattr(self, 'chkShowExt'):
            self.chkShowExt.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowElev'):
            self.chkShowElev.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowDepth'):
            self.chkShowDepth.toggled.connect(self._on_display_changed)
        # Display styling controls
        if hasattr(self, 'fontCombo'):
            self.fontCombo.currentFontChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnFontSize'):
            self.spnFontSize.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'chkBoldLabels'):
            self.chkBoldLabels.toggled.connect(self._on_style_changed)
        if hasattr(self, 'cmbLabelLayout'):
            self.cmbLabelLayout.currentIndexChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnCornerRadius'):
            self.spnCornerRadius.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetX'):
            self.spnOffsetX.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetY'):
            self.spnOffsetY.valueChanged.connect(self._on_style_changed)
        # Restore default style button
        if hasattr(self, 'btnRestoreDefaultStyle'):
            self.btnRestoreDefaultStyle.clicked.connect(self._on_restore_default_style)
        # Recalculate selected segments button
        if hasattr(self, 'btnRecalculateSelected'):
            self.btnRecalculateSelected.clicked.connect(self._on_recalculate_selected)

        # Initialize floater params
        self._push_params_to_floater()
        self._push_display_to_floater()
        # Measure CRS will be pushed when vector layer is set
        # Push initial style to floater
        self._push_style_to_floater()

    def closeEvent(self, event):
        # Ensure floater is removed when closing
        try:
            if self._floater:
                self._floater.stop()
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layerWasAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_line_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_line_layers)
        except Exception:
            pass
        self.closingPlugin.emit()
        event.accept()

    # --- internal -------------------------------------------------------------
    def _pick_first_raster_layer(self):
        if QgsProject.instance() is None:
            return None
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    return lyr
            except Exception:
                continue
        return None

    def _current_dem_layer(self):
        if not hasattr(self, 'cmbDemLayer'):
            return None
        lyr_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _current_band(self) -> int:
        # DEMs are assumed single-band per requirement
        return 1

    def _populate_dem_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbDemLayer'):
            return
        prev_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        self.cmbDemLayer.blockSignals(True)
        self.cmbDemLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    self.cmbDemLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbDemLayer.blockSignals(False)
        # Restore selection if possible
        if prev_id:
            idx = self.cmbDemLayer.findData(prev_id)
            if idx >= 0:
                self.cmbDemLayer.setCurrentIndex(idx)
        # No band selection (assume band 1)

    # Removed band population; fixed to band 1

    def _on_dem_layer_changed(self, idx: int):
        # If running, restart with the new layer
        if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
            self._restart_floater()
        # Warn if CRS differs between DEM and vector layer
        try:
            dem = self._current_dem_layer()
            vec = self._current_line_layer()
            if dem is not None and vec is not None and dem.crs().isValid() and vec.crs().isValid():
                if dem.crs() != vec.crs() and self.iface:
                    self.iface.messageBar().pushWarning(
                        self.tr("Sewerage Depth Estimator"),
                        self.tr("CRS mismatch between DEM (%1) and vector layer (%2).").replace("%1", dem.crs().authid()).replace("%2", vec.crs().authid())
                    )
        except Exception:
            pass
        # Save configuration
        self._save_project_config()

    # Removed band change handler

    def _restart_floater(self):
        if not self._floater:
            return
        lyr = self._current_dem_layer() or self._pick_first_raster_layer()
        if lyr is None:
            if self.iface:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)
            return
        try:
            self._floater.stop()
            self._floater.start(lyr, band=1, number_format="{value:.2f}")
        except Exception:
            if self.iface:
                self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)

    def _on_toggle_estimator(self, enabled: bool):
        if not self._floater:
            return
        if enabled:
            layer = self._current_dem_layer() or self._pick_first_raster_layer()
            if layer is None:
                # Fallback: disable and inform user via message bar if iface is present
                if self.iface:
                    self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
                return
            try:
                self._floater.start(layer, band=1, number_format="{value:.2f}")
            except Exception:
                if self.iface:
                    self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
        else:
            self._floater.stop()

    def _on_params_changed(self, *args):
        self._push_params_to_floater()
        self._save_project_config()

    def _push_params_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.minimum_cover_m = float(self.spnMinCover.value())
            # Diameter is shown in mm in UI; convert to meters for calculations
            self._floater.diameter_m = float(self.spnDiameter.value()) / 1000.0
            self._floater.slope_m_per_m = float(self.spnSlope.value())
            self._floater.initial_depth_m = float(self.spnInitialDepth.value())
        except Exception:
            pass

    def _on_display_changed(self, *args):
        self._push_display_to_floater()
        self._save_project_config()

    def _push_display_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.show_extension = bool(self.chkShowExt.isChecked())
            self._floater.show_elevation = bool(self.chkShowElev.isChecked())
            self._floater.show_depth = bool(self.chkShowDepth.isChecked())
        except Exception:
            pass

    # --- CRS measure handling --------------------------------------------------
    def _init_measure_crs(self):
        # No-op: measure CRS follows vector layer CRS now
        return

    def _on_measure_crs_changed(self):
        # No-op: widget removed
        return

    # --- Layers tab population -------------------------------------------------
    def _populate_line_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbLineLayer'):
            return
        prev_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        self.cmbLineLayer.blockSignals(True)
        self.cmbLineLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.VectorLayer and lyr.geometryType() in (1, 5):  # 1 Line, 5 MultiLine
                    self.cmbLineLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbLineLayer.blockSignals(False)
        if prev_id:
            idx = self.cmbLineLayer.findData(prev_id)
            if idx >= 0:
                self.cmbLineLayer.setCurrentIndex(idx)
        self._populate_numeric_fields()

    def _current_line_layer(self):
        if not hasattr(self, 'cmbLineLayer'):
            return None
        lyr_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _populate_numeric_fields(self):
        lyr = self._current_line_layer()
        combos = [getattr(self, name) for name in ('cmbP1Elev', 'cmbP2Elev', 'cmbP1H', 'cmbP2H') if hasattr(self, name)]
        for cb in combos:
            cb.blockSignals(True)
            cb.clear()
        if lyr is not None:
            try:
                for f in lyr.fields():
                    if f.isNumeric():
                        for cb in combos:
                            cb.addItem(f.name(), f.name())
                # Select defaults if present
                defaults = {
                    'cmbP1Elev': 'p1_elev',
                    'cmbP2Elev': 'p2_elev',
                    'cmbP1H': 'p1_h',
                    'cmbP2H': 'p2_h',
                }
                for name, def_field in defaults.items():
                    if hasattr(self, name):
                        cb = getattr(self, name)
                        idx = cb.findData(def_field)
                        if idx >= 0:
                            cb.setCurrentIndex(idx)
            except Exception:
                pass
        for cb in combos:
            cb.blockSignals(False)

    def _on_line_layer_changed(self, idx: int):
        self._populate_numeric_fields()
        self._push_gate_layer_to_floater()
        self._save_project_config()

        # Handle attribute creation button
        if hasattr(self, 'btnCreateDefaultAttrs'):
            self.btnCreateDefaultAttrs.clicked.connect(self._on_create_default_attrs)
        
        # Monitor selection changes for recalculate button
        self._connect_selection_monitoring()

    def _push_gate_layer_to_floater(self):
        if not self._floater:
            return
        try:
            lyr = self._current_line_layer()
            self._floater.set_gate_line_layer(lyr)
            # Measurement CRS follows vector layer CRS
            if lyr is not None and lyr.crs().isValid():
                self._floater.set_measure_crs(lyr.crs())
        except Exception:
            pass

    def _on_create_default_attrs(self):
        lyr = self._current_line_layer()
        if lyr is None:
            return
        required = ['p1_elev', 'p2_elev', 'p1_h', 'p2_h']
        existing = set([f.name() for f in lyr.fields()])
        if all(name in existing for name in required):
            # Warn already exists
            try:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("Default attributes already exist in the selected layer."))
            except Exception:
                pass
            # still reflect selection
            self._populate_numeric_fields()
            return
        # Add missing numeric fields (double)
        try:
            from qgis.PyQt.QtCore import QVariant
        except Exception:
            QVariant = None
        try:
            caps = lyr.dataProvider().capabilities()
            if not lyr.isEditable():
                lyr.startEditing()
            from qgis.core import QgsField
            for name in required:
                if name not in existing:
                    fld = QgsField(name, 6)  # QVariant.Double == 6 in many builds
                    lyr.addAttribute(fld)
            lyr.updateFields()
            lyr.commitChanges()
        except Exception:
            try:
                lyr.rollback()
            except Exception:
                pass
        # refresh selectors
        self._populate_numeric_fields()

    def _resolve_field_index(self, layer, ui_name: str, default_name: str) -> int:
        """Resolve field index from UI combo or default name"""
        try:
            if hasattr(self, ui_name):
                cb = getattr(self, ui_name)
                name = cb.currentData() if cb.currentIndex() >= 0 else default_name
            else:
                name = default_name
            return layer.fields().indexOf(name)
        except Exception:
            return -1

    # --- Display style handling -----------------------------------------------
    def _init_color_buttons(self):
        # Create color buttons in containers
        self.btnTextColor = None
        self.btnBgColor = None
        if hasattr(self, 'textColorContainer') and self.textColorContainer is not None:
            lay = QtWidgets.QHBoxLayout(self.textColorContainer)
            lay.setContentsMargins(0, 0, 0, 0)
            self.btnTextColor = QgsColorButton(self.textColorContainer)
            self.btnTextColor.setAllowOpacity(True)
            self.btnTextColor.setColor(QtGui.QColor(34, 34, 34, 255))
            self.btnTextColor.colorChanged.connect(self._on_style_changed)
            lay.addWidget(self.btnTextColor)
        if hasattr(self, 'bgColorContainer') and self.bgColorContainer is not None:
            lay2 = QtWidgets.QHBoxLayout(self.bgColorContainer)
            lay2.setContentsMargins(0, 0, 0, 0)
            self.btnBgColor = QgsColorButton(self.bgColorContainer)
            self.btnBgColor.setAllowOpacity(True)
            self.btnBgColor.setColor(QtGui.QColor(240, 240, 240, 200))
            self.btnBgColor.colorChanged.connect(self._on_style_changed)
            lay2.addWidget(self.btnBgColor)

    def _on_style_changed(self, *args):
        self._push_style_to_floater()
        self._save_project_config()

    def _push_style_to_floater(self):
        if not self._floater:
            return
        try:
            font = self.fontCombo.currentFont() if hasattr(self, 'fontCombo') else QtGui.QFont()
            size = int(self.spnFontSize.value()) if hasattr(self, 'spnFontSize') else 11
            bold_labels = bool(self.chkBoldLabels.isChecked()) if hasattr(self, 'chkBoldLabels') else True
            text_color = self.btnTextColor.color() if self.btnTextColor else QtGui.QColor(34, 34, 34)
            bg_color = self.btnBgColor.color() if self.btnBgColor else QtGui.QColor(240, 240, 240)
            layout_mode = 'vertical'
            if hasattr(self, 'cmbLabelLayout') and self.cmbLabelLayout.currentIndex() == 1:
                layout_mode = 'horizontal'
            corner = float(self.spnCornerRadius.value()) if hasattr(self, 'spnCornerRadius') else 3.5
            offx = int(self.spnOffsetX.value()) if hasattr(self, 'spnOffsetX') else 14
            offy = int(self.spnOffsetY.value()) if hasattr(self, 'spnOffsetY') else 10
            self._floater.set_style(font, size, text_color, bg_color, bold_labels)
            self._floater.set_layout_mode(layout_mode)
            self._floater.set_bubble_style(corner_radius=corner, offset_x=offx, offset_y=offy)
        except Exception:
            pass

    def _on_restore_default_style(self):
        try:
            # Defaults
            default_font = QtGui.QFont('Calibri')
            default_size = 11
            default_bold = True
            default_text = QtGui.QColor(34, 34, 34, 255)
            default_bg = QtGui.QColor(240, 240, 240, 200)
            default_layout = 'Vertical'
            default_corner = 3.5
            default_offx = 14
            default_offy = 10

            if hasattr(self, 'fontCombo'):
                self.fontCombo.setCurrentFont(default_font)
            if hasattr(self, 'spnFontSize'):
                self.spnFontSize.setValue(default_size)
            if hasattr(self, 'chkBoldLabels'):
                self.chkBoldLabels.setChecked(default_bold)
            if hasattr(self, 'btnTextColor') and self.btnTextColor:
                try:
                    self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnTextColor.setColor(default_text)
                self.btnTextColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'btnBgColor') and self.btnBgColor:
                try:
                    self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnBgColor.setColor(default_bg)
                self.btnBgColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'cmbLabelLayout'):
                idx = self.cmbLabelLayout.findText(default_layout)
                if idx >= 0:
                    self.cmbLabelLayout.setCurrentIndex(idx)
            if hasattr(self, 'spnCornerRadius'):
                self.spnCornerRadius.setValue(default_corner)
            if hasattr(self, 'spnOffsetX'):
                self.spnOffsetX.setValue(default_offx)
            if hasattr(self, 'spnOffsetY'):
                self.spnOffsetY.setValue(default_offy)

            # Apply and persist
            self._push_style_to_floater()
            self._save_project_config()
        except Exception:
            pass

    # Project Configuration Save/Load ----------------------------------------
    def _load_project_config(self):
        """Load plugin configuration from QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Load the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                estimate_enabled, ok = project.readBoolEntry(plugin_group, "estimate_enabled", False)
                if ok:
                    self.chkEstimateDepth.setChecked(estimate_enabled)
            
            # Load DEM layer and band
            dem_layer_id, ok = project.readEntry(plugin_group, "dem_layer_id", "")
            if ok and dem_layer_id:
                # Find layer by ID and select it
                layer = QgsProject.instance().mapLayer(dem_layer_id)
                if layer and hasattr(self, 'cmbDemLayer'):
                    for i in range(self.cmbDemLayer.count()):
                        if self.cmbDemLayer.itemData(i) == dem_layer_id:
                            self.cmbDemLayer.setCurrentIndex(i)
                            break
            
            # Load DEM band
            dem_band, ok = project.readNumEntry(plugin_group, "dem_band", 1)
            if ok and hasattr(self, 'cmbDemBand'):
                for i in range(self.cmbDemBand.count()):
                    if self.cmbDemBand.itemData(i) == dem_band:
                        self.cmbDemBand.setCurrentIndex(i)
                        break
            
            # Load sewer vector layer
            sewer_layer_id, ok = project.readEntry(plugin_group, "sewer_layer_id", "")
            if ok and sewer_layer_id:
                layer = QgsProject.instance().mapLayer(sewer_layer_id)
                if layer and hasattr(self, 'cmbLineLayer'):
                    for i in range(self.cmbLineLayer.count()):
                        if self.cmbLineLayer.itemData(i) == sewer_layer_id:
                            self.cmbLineLayer.setCurrentIndex(i)
                            break
            
            # Load parameters
            if hasattr(self, 'spnMinCover'):
                min_cover, ok = project.readDoubleEntry(plugin_group, "min_cover", 0.9)
                if ok:
                    self.spnMinCover.setValue(min_cover)
            
            if hasattr(self, 'spnDiameter'):
                diameter, ok = project.readNumEntry(plugin_group, "diameter_mm", 150)
                if ok:
                    self.spnDiameter.setValue(diameter)
            
            if hasattr(self, 'spnSlope'):
                slope, ok = project.readDoubleEntry(plugin_group, "slope", 0.005)
                if ok:
                    self.spnSlope.setValue(slope)
            
            if hasattr(self, 'spnInitialDepth'):
                initial_depth, ok = project.readDoubleEntry(plugin_group, "initial_depth", 0.0)
                if ok:
                    self.spnInitialDepth.setValue(initial_depth)
            
            # Load display settings
            if hasattr(self, 'chkShowExt'):
                show_ext, ok = project.readBoolEntry(plugin_group, "show_extension", True)
                if ok:
                    self.chkShowExt.setChecked(show_ext)
            
            if hasattr(self, 'chkShowElev'):
                show_elev, ok = project.readBoolEntry(plugin_group, "show_elevation", True)
                if ok:
                    self.chkShowElev.setChecked(show_elev)
            
            if hasattr(self, 'chkShowDepth'):
                show_depth, ok = project.readBoolEntry(plugin_group, "show_depth", True)
                if ok:
                    self.chkShowDepth.setChecked(show_depth)
            
            # Load style settings
            if hasattr(self, 'spnFontSize'):
                font_size, ok = project.readNumEntry(plugin_group, "font_size", 9)
                if ok:
                    self.spnFontSize.setValue(font_size)
            
            if hasattr(self, 'chkBoldLabels'):
                bold_labels, ok = project.readBoolEntry(plugin_group, "bold_labels", True)
                if ok:
                    self.chkBoldLabels.setChecked(bold_labels)
            
            # Load font family
            if hasattr(self, 'fontCombo'):
                font_family, ok = project.readEntry(plugin_group, "font_family", "")
                if ok and font_family:
                    try:
                        f = QtGui.QFont()
                        f.setFamily(font_family)
                        self.fontCombo.setCurrentFont(f)
                    except Exception:
                        pass

            # Load text and background colors (stored as r,g,b,a)
            try:
                text_color_str, ok = project.readEntry(plugin_group, "text_color_rgba", "")
                if ok and text_color_str and hasattr(self, 'btnTextColor') and self.btnTextColor:
                    parts = [int(p) for p in text_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnTextColor.setColor(color)
                        # Reconnect signal
                        self.btnTextColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            try:
                bg_color_str, ok = project.readEntry(plugin_group, "bg_color_rgba", "")
                if ok and bg_color_str and hasattr(self, 'btnBgColor') and self.btnBgColor:
                    parts = [int(p) for p in bg_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnBgColor.setColor(color)
                        # Reconnect signal
                        self.btnBgColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                layout_mode, ok = project.readEntry(plugin_group, "label_layout", "Vertical")
                if ok:
                    index = self.cmbLabelLayout.findText(layout_mode)
                    if index >= 0:
                        self.cmbLabelLayout.setCurrentIndex(index)
            
            if hasattr(self, 'spnCornerRadius'):
                corner_radius, ok = project.readDoubleEntry(plugin_group, "corner_radius", 3.5)
                if ok:
                    self.spnCornerRadius.setValue(corner_radius)
            
            if hasattr(self, 'spnOffsetX'):
                offset_x, ok = project.readNumEntry(plugin_group, "offset_x", 14)
                if ok:
                    self.spnOffsetX.setValue(offset_x)
            
            if hasattr(self, 'spnOffsetY'):
                offset_y, ok = project.readNumEntry(plugin_group, "offset_y", 10)
                if ok:
                    self.spnOffsetY.setValue(offset_y)
            
            # Ensure attribute combos are populated for the restored layer
            try:
                self._populate_numeric_fields()
                self._push_gate_layer_to_floater()
                # Ensure floater style reflects restored settings
                self._push_style_to_floater()
                # IMPORTANT: Restart floater with the restored DEM settings
                # This ensures the interpolator is initialized with the correct DEM
                if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
                    self._restart_floater()
            except Exception:
                pass

            print("[SEWERAGE DEBUG] Loaded project configuration")
            
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error loading project config: {e}")
    
    def _save_project_config(self):
        """Save plugin configuration to QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Save the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                project.writeEntry(plugin_group, "estimate_enabled", str(self.chkEstimateDepth.isChecked()))
            
            # Save DEM layer and band
            if hasattr(self, 'cmbDemLayer') and self.cmbDemLayer.currentIndex() >= 0:
                dem_layer_id = self.cmbDemLayer.currentData()
                if dem_layer_id:
                    project.writeEntry(plugin_group, "dem_layer_id", dem_layer_id)
            
            if hasattr(self, 'cmbDemBand') and self.cmbDemBand.currentIndex() >= 0:
                dem_band = self.cmbDemBand.currentData()
                if dem_band is not None:
                    project.writeEntry(plugin_group, "dem_band", str(dem_band))
            
            # Save sewer vector layer
            if hasattr(self, 'cmbLineLayer') and self.cmbLineLayer.currentIndex() >= 0:
                sewer_layer_id = self.cmbLineLayer.currentData()
                if sewer_layer_id:
                    project.writeEntry(plugin_group, "sewer_layer_id", sewer_layer_id)
            
            # Save parameters
            if hasattr(self, 'spnMinCover'):
                project.writeEntry(plugin_group, "min_cover", str(self.spnMinCover.value()))
            
            if hasattr(self, 'spnDiameter'):
                project.writeEntry(plugin_group, "diameter_mm", str(self.spnDiameter.value()))
            
            if hasattr(self, 'spnSlope'):
                project.writeEntry(plugin_group, "slope", str(self.spnSlope.value()))
            
            if hasattr(self, 'spnInitialDepth'):
                project.writeEntry(plugin_group, "initial_depth", str(self.spnInitialDepth.value()))
            
            # Save display settings
            if hasattr(self, 'chkShowExt'):
                project.writeEntry(plugin_group, "show_extension", str(self.chkShowExt.isChecked()))
            
            if hasattr(self, 'chkShowElev'):
                project.writeEntry(plugin_group, "show_elevation", str(self.chkShowElev.isChecked()))
            
            if hasattr(self, 'chkShowDepth'):
                project.writeEntry(plugin_group, "show_depth", str(self.chkShowDepth.isChecked()))
            
            # Save style settings
            if hasattr(self, 'spnFontSize'):
                project.writeEntry(plugin_group, "font_size", str(self.spnFontSize.value()))
            
            if hasattr(self, 'chkBoldLabels'):
                project.writeEntry(plugin_group, "bold_labels", str(self.chkBoldLabels.isChecked()))
            
            # Save font family
            if hasattr(self, 'fontCombo'):
                try:
                    project.writeEntry(plugin_group, "font_family", self.fontCombo.currentFont().family())
                except Exception:
                    pass

            # Save colors as r,g,b,a
            try:
                if hasattr(self, 'btnTextColor') and self.btnTextColor:
                    c = self.btnTextColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "text_color_rgba", color_str)
            except Exception:
                pass

            try:
                if hasattr(self, 'btnBgColor') and self.btnBgColor:
                    c = self.btnBgColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "bg_color_rgba", color_str)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                project.writeEntry(plugin_group, "label_layout", self.cmbLabelLayout.currentText())
            
            if hasattr(self, 'spnCornerRadius'):
                project.writeEntry(plugin_group, "corner_radius", str(self.spnCornerRadius.value()))
            
            if hasattr(self, 'spnOffsetX'):
                project.writeEntry(plugin_group, "offset_x", str(self.spnOffsetX.value()))
            
            if hasattr(self, 'spnOffsetY'):
                project.writeEntry(plugin_group, "offset_y", str(self.spnOffsetY.value()))
            
            print("[SEWERAGE DEBUG] Saved project configuration")
            
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error saving project config: {e}")

    def _connect_selection_monitoring(self):
        """Connect selection change monitoring for current line layer"""
        try:
            print("[SEWERAGE DEBUG] Setting up selection monitoring...")
            
            # Disconnect previous connections
            if hasattr(self, '_current_monitored_layer') and self._current_monitored_layer:
                try:
                    self._current_monitored_layer.selectionChanged.disconnect(self._on_selection_changed)
                    print(f"[SEWERAGE DEBUG] Disconnected from previous layer: {self._current_monitored_layer.name()}")
                except:
                    pass
            
            # Connect to current layer
            layer = self._current_line_layer()
            if layer:
                layer.selectionChanged.connect(self._on_selection_changed)
                self._current_monitored_layer = layer
                print(f"[SEWERAGE DEBUG] Connected selection monitoring to layer: {layer.name()}")
                # Update button state immediately
                self._on_selection_changed()
            else:
                self._current_monitored_layer = None
                self._update_recalculate_button_state(False)
                print("[SEWERAGE DEBUG] No line layer available for selection monitoring")
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error connecting selection monitoring: {e}")

    def _on_selection_changed(self):
        """Update recalculate button state based on selection"""
        try:
            layer = self._current_line_layer()
            if layer:
                selected_count = len(layer.selectedFeatures())
                has_selection = selected_count > 0
                print(f"[SEWERAGE DEBUG] Selection changed: {selected_count} features selected in {layer.name()}")
                self._update_recalculate_button_state(has_selection)
            else:
                print("[SEWERAGE DEBUG] Selection changed but no layer available")
                self._update_recalculate_button_state(False)
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error in selection changed: {e}")

    def _update_recalculate_button_state(self, enabled: bool):
        """Enable/disable recalculate button"""
        if hasattr(self, 'btnRecalculateSelected'):
            self.btnRecalculateSelected.setEnabled(enabled)
            print(f"[SEWERAGE DEBUG] Recalculate button enabled: {enabled}")
        else:
            print("[SEWERAGE DEBUG] btnRecalculateSelected not found!")

    def _on_recalculate_selected(self):
        """Recalculate depths for selected segments"""
        try:
            layer = self._current_line_layer()
            if not layer:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No line layer selected")
                return
            
            selected_features = layer.selectedFeatures()
            if not selected_features:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No features selected")
                return

            # Get current parameters
            min_cover = self.spnMinCover.value() if hasattr(self, 'spnMinCover') else 0.9
            diameter = self.spnDiameter.value() / 1000.0 if hasattr(self, 'spnDiameter') else 0.15  # Convert mm to m
            slope = self.spnSlope.value() if hasattr(self, 'spnSlope') else 0.005
            initial_depth = self.spnInitialDepth.value() if hasattr(self, 'spnInitialDepth') else 0.0

            # Get DEM layer for elevation interpolation
            dem_layer = self._current_dem_layer()
            if not dem_layer:
                if self.iface:
                    self.iface.messageBar().pushWarning("Sewerage Depth Estimator", "No DEM layer selected")
                return

            # Start editing if needed
            if not layer.isEditable():
                layer.startEditing()

            # Clear existing depths and interpolate missing elevations
            self._prepare_selected_features(selected_features, layer, dem_layer)

            # Calculate depths using tree algorithm
            self._calculate_tree_depths(selected_features, layer, min_cover, diameter, slope, initial_depth)

            if self.iface:
                self.iface.messageBar().pushSuccess("Sewerage Depth Estimator", 
                                                   f"Recalculated depths for {len(selected_features)} segments")

        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error in recalculate selected: {e}")
            if self.iface:
                self.iface.messageBar().pushCritical("Sewerage Depth Estimator", f"Error: {str(e)}")

    def _prepare_selected_features(self, selected_features, layer, dem_layer):
        """Clear depths and interpolate missing elevations for selected features"""
        from .elevation_floater import RasterInterpolator
        from qgis.core import QgsCoordinateTransform, QgsProject, QgsPointXY
        
        # Get field indices
        field_mapping = self._get_field_mapping(layer)
        p1_elev_idx = field_mapping.get('p1_elev', -1)
        p2_elev_idx = field_mapping.get('p2_elev', -1)
        p1_h_idx = field_mapping.get('p1_h', -1)
        p2_h_idx = field_mapping.get('p2_h', -1)

        # Setup raster interpolator
        interpolator = RasterInterpolator(dem_layer, band=1)
        transform_context = QgsProject.instance().transformContext()
        to_raster = QgsCoordinateTransform(layer.crs(), dem_layer.crs(), transform_context)

        for feature in selected_features:
            try:
                # Clear existing depths
                if p1_h_idx >= 0:
                    layer.changeAttributeValue(feature.id(), p1_h_idx, None)
                if p2_h_idx >= 0:
                    layer.changeAttributeValue(feature.id(), p2_h_idx, None)

                # Get geometry endpoints
                geom = feature.geometry()
                if geom.isEmpty():
                    continue
                
                if geom.isMultipart():
                    lines = geom.asMultiPolyline()
                    if not lines:
                        continue
                    pts = lines[0]
                else:
                    pts = geom.asPolyline()
                
                if len(pts) < 2:
                    continue

                p1, p2 = QgsPointXY(pts[0]), QgsPointXY(pts[-1])

                # Interpolate missing elevations
                if p1_elev_idx >= 0:
                    p1_elev = feature.attribute(p1_elev_idx)
                    if p1_elev is None or p1_elev == '':
                        try:
                            p1_raster = to_raster.transform(p1)
                            elev = interpolator.bilinear(p1_raster)
                            if elev is not None:
                                layer.changeAttributeValue(feature.id(), p1_elev_idx, round(float(elev), 2))
                        except:
                            pass

                if p2_elev_idx >= 0:
                    p2_elev = feature.attribute(p2_elev_idx)
                    if p2_elev is None or p2_elev == '':
                        try:
                            p2_raster = to_raster.transform(p2)
                            elev = interpolator.bilinear(p2_raster)
                            if elev is not None:
                                layer.changeAttributeValue(feature.id(), p2_elev_idx, round(float(elev), 2))
                        except:
                            pass

            except Exception as e:
                print(f"[SEWERAGE DEBUG] Error preparing feature {feature.id()}: {e}")

    def _calculate_tree_depths(self, selected_features, layer, min_cover, diameter, slope, initial_depth):
        """Calculate depths using tree traversal algorithm for open sewerage networks"""
        from qgis.core import QgsPointXY
        
        # Get field indices
        field_mapping = self._get_field_mapping(layer)
        p1_elev_idx = field_mapping.get('p1_elev', -1)
        p2_elev_idx = field_mapping.get('p2_elev', -1)
        p1_h_idx = field_mapping.get('p1_h', -1)
        p2_h_idx = field_mapping.get('p2_h', -1)

        if min(p1_elev_idx, p2_elev_idx, p1_h_idx, p2_h_idx) < 0:
            raise Exception("Missing required elevation or depth fields")

        # Build network topology
        segments = []
        node_connections = {}  # node_key -> list of (segment_idx, is_upstream)

        def node_key(pt: QgsPointXY) -> str:
            return f"{pt.x():.6f},{pt.y():.6f}"

        # Extract segments and build topology
        for i, feature in enumerate(selected_features):
            geom = feature.geometry()
            if geom.isEmpty():
                continue
                
            if geom.isMultipart():
                lines = geom.asMultiPolyline()
                if not lines:
                    continue
                pts = lines[0]
            else:
                pts = geom.asPolyline()
            
            if len(pts) < 2:
                continue

            p1, p2 = QgsPointXY(pts[0]), QgsPointXY(pts[-1])
            
            # Get elevations
            p1_elev = feature.attribute(p1_elev_idx)
            p2_elev = feature.attribute(p2_elev_idx)
            
            try:
                p1_elev = float(p1_elev) if p1_elev not in (None, '') else None
                p2_elev = float(p2_elev) if p2_elev not in (None, '') else None
            except:
                continue

            if p1_elev is None or p2_elev is None:
                continue

            # Calculate segment length
            seg_length = ((p2.x() - p1.x()) ** 2 + (p2.y() - p1.y()) ** 2) ** 0.5

            segment_data = {
                'feature': feature,
                'p1': p1,
                'p2': p2,
                'p1_elev': p1_elev,
                'p2_elev': p2_elev,
                'length': seg_length,
                'processed': False
            }
            segments.append(segment_data)

            # Update topology
            p1_key = node_key(p1)
            p2_key = node_key(p2)
            
            node_connections.setdefault(p1_key, []).append((i, True))   # p1 is upstream
            node_connections.setdefault(p2_key, []).append((i, False))  # p2 is downstream

        # Find root segments (no upstream connections)
        roots = []
        for i, seg in enumerate(segments):
            p1_key = node_key(seg['p1'])
            has_upstream = any(not is_upstream for _, is_upstream in node_connections.get(p1_key, []))
            if not has_upstream:
                roots.append(i)

        print(f"[SEWERAGE DEBUG] Found {len(roots)} root segments from {len(segments)} total")

        # Process each tree starting from roots
        for root_idx in roots:
            self._process_tree_branch(root_idx, segments, node_connections, layer, 
                                    min_cover, diameter, slope, initial_depth,
                                    p1_h_idx, p2_h_idx)

    def _process_tree_branch(self, seg_idx, segments, node_connections, layer,
                           min_cover, diameter, slope, initial_depth,
                           p1_h_idx, p2_h_idx):
        """Process a branch of the tree starting from given segment"""
        def node_key(pt):
            return f"{pt.x():.6f},{pt.y():.6f}"

        stack = [(seg_idx, initial_depth if initial_depth > 0 else None)]
        
        while stack:
            current_idx, upstream_depth = stack.pop()
            segment = segments[current_idx]
            
            if segment['processed']:
                continue
                
            segment['processed'] = True
            
            # Calculate upstream depth if not provided
            if upstream_depth is None:
                # Use minimum cover + diameter
                total_depth = min_cover + diameter
                upstream_depth = total_depth
            
            # Calculate downstream depth considering slope and minimum cover
            fall = segment['length'] * slope
            downstream_candidate = upstream_depth + fall
            
            # Enforce minimum cover at downstream
            min_downstream = min_cover + diameter
            downstream_depth = max(downstream_candidate, min_downstream)
            
            # Write depths to feature
            feature = segment['feature']
            layer.changeAttributeValue(feature.id(), p1_h_idx, round(upstream_depth, 2))
            layer.changeAttributeValue(feature.id(), p2_h_idx, round(downstream_depth, 2))
            
            print(f"[SEWERAGE DEBUG] Segment {feature.id()}: upstream={upstream_depth:.2f}m, downstream={downstream_depth:.2f}m")
            
            # Find downstream segments
            p2_key = node_key(segment['p2'])
            downstream_segments = [idx for idx, is_upstream in node_connections.get(p2_key, []) if is_upstream]
            
            # Add downstream segments to stack
            for ds_idx in downstream_segments:
                if not segments[ds_idx]['processed']:
                    stack.append((ds_idx, downstream_depth))

    def _get_field_mapping(self, layer):
        """Get field mapping for the given layer"""
        try:
            p1e_idx = self._resolve_field_index(layer, 'cmbP1Elev', 'p1_elev')
            p2e_idx = self._resolve_field_index(layer, 'cmbP2Elev', 'p2_elev') 
            p1h_idx = self._resolve_field_index(layer, 'cmbP1H', 'p1_h')
            p2h_idx = self._resolve_field_index(layer, 'cmbP2H', 'p2_h')
            
            return {
                'p1_elev': p1e_idx,
                'p2_elev': p2e_idx,
                'p1_h': p1h_idx,
                'p2_h': p2h_idx
            }
        except:
            return {
                'p1_elev': layer.fields().indexOf('p1_elev'),
                'p2_elev': layer.fields().indexOf('p2_elev'),
                'p1_h': layer.fields().indexOf('p1_h'),
                'p2_h': layer.fields().indexOf('p2_h')
            }
