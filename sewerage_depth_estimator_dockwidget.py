# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SewerageDepthEstimatorDockWidget
                                 A QGIS plugin
 Estimate the depth of sewer network based on simplified parameters
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-08
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonardo Nazareth
        email                : leonazareth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject, QgsMapLayer, QgsCoordinateReferenceSystem, QgsPointXY
try:
    from qgis.gui import QgsProjectionSelectionWidget
except Exception:  # pragma: no cover - optional in some envs
    QgsProjectionSelectionWidget = None
from qgis.gui import QgsColorButton

from .elevation_floater import ElevationFloaterController

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'sewerage_depth_estimator_dockwidget_base.ui'))


class SewerageDepthEstimatorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface=None, parent=None):
        """Constructor."""
        super(SewerageDepthEstimatorDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # QGIS iface and canvas
        self.iface = iface
        self.canvas = self.iface.mapCanvas() if self.iface else None

        # Elevation floater controller (non-intrusive, does not change active tool)
        self._floater = ElevationFloaterController(self.iface) if self.iface else None

        # Wire checkbox
        if hasattr(self, 'chkEstimateDepth'):
            self.chkEstimateDepth.toggled.connect(self._on_toggle_estimator)

        # Populate DEM layers and watch project changes
        self._populate_dem_layers()
        QgsProject.instance().layersAdded.connect(self._populate_dem_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_dem_layers)
        QgsProject.instance().layerWasAdded.connect(self._populate_dem_layers)
        # Populate vector line layers for Layers tab
        self._populate_line_layers()
        QgsProject.instance().layersAdded.connect(self._populate_line_layers)
        QgsProject.instance().layersRemoved.connect(self._populate_line_layers)
        
        # Initialize color buttons BEFORE loading project config so they exist when colors are loaded
        self._init_color_buttons()
        
        # Load saved project configuration AFTER both DEM and Line layer combos and color buttons are ready
        # so that saved selections can be restored correctly.
        self._load_project_config()
        if hasattr(self, 'cmbLineLayer'):
            self.cmbLineLayer.currentIndexChanged.connect(self._on_line_layer_changed)
            self._push_gate_layer_to_floater()
        if hasattr(self, 'cmbDemLayer'):
            self.cmbDemLayer.currentIndexChanged.connect(self._on_dem_layer_changed)
        # Wire recalc button and selection watcher
        if hasattr(self, 'btnRecalcSelected'):
            self.btnRecalcSelected.clicked.connect(self._on_recalc_selected)
            self.btnRecalcSelected.setEnabled(False)
        # Ensure selection listener is wired for the initially selected layer
        try:
            self._sel_layer = None
            self._wire_selection_listener(self._current_line_layer())
        except Exception:
            pass
        # No CRS selection widget; measure CRS will follow vector layer
        # Parameters wiring
        if hasattr(self, 'spnMinCover'):
            self.spnMinCover.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnDiameter'):
            self.spnDiameter.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnSlope'):
            self.spnSlope.valueChanged.connect(self._on_params_changed)
        if hasattr(self, 'spnInitialDepth'):
            self.spnInitialDepth.valueChanged.connect(self._on_params_changed)
        # Display toggles
        if hasattr(self, 'chkShowExt'):
            self.chkShowExt.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowElev'):
            self.chkShowElev.toggled.connect(self._on_display_changed)
        if hasattr(self, 'chkShowDepth'):
            self.chkShowDepth.toggled.connect(self._on_display_changed)
        # Display styling controls
        if hasattr(self, 'fontCombo'):
            self.fontCombo.currentFontChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnFontSize'):
            self.spnFontSize.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'chkBoldLabels'):
            self.chkBoldLabels.toggled.connect(self._on_style_changed)
        if hasattr(self, 'cmbLabelLayout'):
            self.cmbLabelLayout.currentIndexChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnCornerRadius'):
            self.spnCornerRadius.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetX'):
            self.spnOffsetX.valueChanged.connect(self._on_style_changed)
        if hasattr(self, 'spnOffsetY'):
            self.spnOffsetY.valueChanged.connect(self._on_style_changed)
        # Restore default style button
        if hasattr(self, 'btnRestoreDefaultStyle'):
            self.btnRestoreDefaultStyle.clicked.connect(self._on_restore_default_style)

        # Initialize floater params
        self._push_params_to_floater()
        self._push_display_to_floater()
        # Measure CRS will be pushed when vector layer is set
        # Push initial style to floater
        self._push_style_to_floater()

    def closeEvent(self, event):
        # Ensure floater is removed when closing
        try:
            if self._floater:
                self._floater.stop()
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layerWasAdded.disconnect(self._populate_dem_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersAdded.disconnect(self._populate_line_layers)
        except Exception:
            pass
        try:
            QgsProject.instance().layersRemoved.disconnect(self._populate_line_layers)
        except Exception:
            pass
        self.closingPlugin.emit()
        event.accept()

    # --- internal -------------------------------------------------------------
    def _pick_first_raster_layer(self):
        if QgsProject.instance() is None:
            return None
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    return lyr
            except Exception:
                continue
        return None

    def _current_dem_layer(self):
        if not hasattr(self, 'cmbDemLayer'):
            return None
        lyr_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _current_band(self) -> int:
        # DEMs are assumed single-band per requirement
        return 1

    def _populate_dem_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbDemLayer'):
            return
        prev_id = self.cmbDemLayer.currentData() if self.cmbDemLayer.count() > 0 else None
        self.cmbDemLayer.blockSignals(True)
        self.cmbDemLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.RasterLayer:
                    self.cmbDemLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbDemLayer.blockSignals(False)
        # Restore selection if possible
        if prev_id:
            idx = self.cmbDemLayer.findData(prev_id)
            if idx >= 0:
                self.cmbDemLayer.setCurrentIndex(idx)
        # No band selection (assume band 1)

    # Removed band population; fixed to band 1

    def _on_dem_layer_changed(self, idx: int):
        # If running, restart with the new layer
        if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
            self._restart_floater()
        # Warn if CRS differs between DEM and vector layer
        try:
            dem = self._current_dem_layer()
            vec = self._current_line_layer()
            if dem is not None and vec is not None and dem.crs().isValid() and vec.crs().isValid():
                if dem.crs() != vec.crs() and self.iface:
                    self.iface.messageBar().pushWarning(
                        self.tr("Sewerage Depth Estimator"),
                        self.tr("CRS mismatch between DEM (%1) and vector layer (%2).").replace("%1", dem.crs().authid()).replace("%2", vec.crs().authid())
                    )
        except Exception:
            pass
        # Save configuration
        self._save_project_config()

    # Removed band change handler

    def _restart_floater(self):
        if not self._floater:
            return
        lyr = self._current_dem_layer() or self._pick_first_raster_layer()
        if lyr is None:
            if self.iface:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)
            return
        try:
            self._floater.stop()
            self._floater.start(lyr, band=1, number_format="{value:.2f}")
        except Exception:
            if self.iface:
                self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
            self.chkEstimateDepth.blockSignals(True)
            self.chkEstimateDepth.setChecked(False)
            self.chkEstimateDepth.blockSignals(False)

    def _on_toggle_estimator(self, enabled: bool):
        if not self._floater:
            return
        if enabled:
            layer = self._current_dem_layer() or self._pick_first_raster_layer()
            if layer is None:
                # Fallback: disable and inform user via message bar if iface is present
                if self.iface:
                    self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No raster DEM found in the project."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
                return
            try:
                self._floater.start(layer, band=1, number_format="{value:.2f}")
            except Exception:
                if self.iface:
                    self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Failed to start elevation floater."))
                self.chkEstimateDepth.blockSignals(True)
                self.chkEstimateDepth.setChecked(False)
                self.chkEstimateDepth.blockSignals(False)
        else:
            self._floater.stop()

    def _on_params_changed(self, *args):
        self._push_params_to_floater()
        self._save_project_config()

    def _push_params_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.minimum_cover_m = float(self.spnMinCover.value())
            # Diameter is shown in mm in UI; convert to meters for calculations
            self._floater.diameter_m = float(self.spnDiameter.value()) / 1000.0
            self._floater.slope_m_per_m = float(self.spnSlope.value())
            self._floater.initial_depth_m = float(self.spnInitialDepth.value())
        except Exception:
            pass

    def _on_display_changed(self, *args):
        self._push_display_to_floater()
        self._save_project_config()

    def _push_display_to_floater(self):
        if not self._floater:
            return
        try:
            self._floater.show_extension = bool(self.chkShowExt.isChecked())
            self._floater.show_elevation = bool(self.chkShowElev.isChecked())
            self._floater.show_depth = bool(self.chkShowDepth.isChecked())
        except Exception:
            pass

    # --- CRS measure handling --------------------------------------------------
    def _init_measure_crs(self):
        # No-op: measure CRS follows vector layer CRS now
        return

    def _on_measure_crs_changed(self):
        # No-op: widget removed
        return

    # --- Layers tab population -------------------------------------------------
    def _populate_line_layers(self, *args, **kwargs):
        if not hasattr(self, 'cmbLineLayer'):
            return
        prev_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        self.cmbLineLayer.blockSignals(True)
        self.cmbLineLayer.clear()
        for lyr in QgsProject.instance().mapLayers().values():
            try:
                if lyr.type() == QgsMapLayer.VectorLayer and lyr.geometryType() in (1, 5):  # 1 Line, 5 MultiLine
                    self.cmbLineLayer.addItem(lyr.name(), lyr.id())
            except Exception:
                continue
        self.cmbLineLayer.blockSignals(False)
        if prev_id:
            idx = self.cmbLineLayer.findData(prev_id)
            if idx >= 0:
                self.cmbLineLayer.setCurrentIndex(idx)
        self._populate_numeric_fields()

    def _current_line_layer(self):
        if not hasattr(self, 'cmbLineLayer'):
            return None
        lyr_id = self.cmbLineLayer.currentData() if self.cmbLineLayer.count() > 0 else None
        if not lyr_id:
            return None
        return QgsProject.instance().mapLayer(lyr_id)

    def _populate_numeric_fields(self):
        lyr = self._current_line_layer()
        combos = [getattr(self, name) for name in ('cmbP1Elev', 'cmbP2Elev', 'cmbP1H', 'cmbP2H') if hasattr(self, name)]
        for cb in combos:
            cb.blockSignals(True)
            cb.clear()
        if lyr is not None:
            try:
                for f in lyr.fields():
                    if f.isNumeric():
                        for cb in combos:
                            cb.addItem(f.name(), f.name())
                # Select defaults if present
                defaults = {
                    'cmbP1Elev': 'p1_elev',
                    'cmbP2Elev': 'p2_elev',
                    'cmbP1H': 'p1_h',
                    'cmbP2H': 'p2_h',
                }
                for name, def_field in defaults.items():
                    if hasattr(self, name):
                        cb = getattr(self, name)
                        idx = cb.findData(def_field)
                        if idx >= 0:
                            cb.setCurrentIndex(idx)
            except Exception:
                pass
        for cb in combos:
            cb.blockSignals(False)

    def _on_line_layer_changed(self, idx: int):
        self._populate_numeric_fields()
        self._push_gate_layer_to_floater()
        self._save_project_config()

        # Handle attribute creation button
        if hasattr(self, 'btnCreateDefaultAttrs'):
            self.btnCreateDefaultAttrs.clicked.connect(self._on_create_default_attrs)
        # Track selection changes to enable/disable recalc button
        self._wire_selection_listener(self._current_line_layer())

    def _push_gate_layer_to_floater(self):
        if not self._floater:
            return
        try:
            lyr = self._current_line_layer()
            self._floater.set_gate_line_layer(lyr)
            # Measurement CRS follows vector layer CRS
            if lyr is not None and lyr.crs().isValid():
                self._floater.set_measure_crs(lyr.crs())
            # Also wire selection watcher on layer change
            self._wire_selection_listener(lyr)
        except Exception:
            pass

    def _on_selection_changed(self, *args):
        try:
            lyr = self._current_line_layer()
            has_sel = bool(lyr and lyr.selectedFeatureCount() > 0)
            if hasattr(self, 'btnRecalcSelected'):
                self.btnRecalcSelected.setEnabled(has_sel)
        except Exception:
            if hasattr(self, 'btnRecalcSelected'):
                self.btnRecalcSelected.setEnabled(False)

    def _on_recalc_selected(self):
        lyr = self._current_line_layer()
        if lyr is None or not self._floater:
            return
        # Ensure latest params
        self._push_params_to_floater()
        try:
            sel_fids = lyr.selectedFeatureIds()
            if not sel_fids:
                return
            # Resolve field indices
            p1e = self._resolve_field_index(lyr, 'cmbP1Elev', 'p1_elev')
            p2e = self._resolve_field_index(lyr, 'cmbP2Elev', 'p2_elev')
            p1h = self._resolve_field_index(lyr, 'cmbP1H', 'p1_h')
            p2h = self._resolve_field_index(lyr, 'cmbP2H', 'p2_h')
            if min(p1e, p2e, p1h, p2h) < 0:
                if self.iface:
                    self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("Configure p1/p2 fields before recalculation."))
                return
            if not lyr.isEditable():
                lyr.startEditing()

            # Clear existing depths
            for fid in sel_fids:
                try:
                    lyr.changeAttributeValue(fid, p1h, None)
                    lyr.changeAttributeValue(fid, p2h, None)
                except Exception:
                    pass

            # Ensure DEM and floater are ready for interpolation
            dem = self._current_dem_layer() or self._pick_first_raster_layer()
            if dem is None:
                if self.iface:
                    self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("No DEM set for elevation interpolation."))
                return
            try:
                self._floater.start(dem, band=1, number_format="{value:.2f}")
            except Exception:
                pass

            # Collect features and coordinates
            features = {f.id(): f for f in lyr.getFeatures(sel_fids)}
            coords_by_fid = {}
            for fid, f in features.items():
                try:
                    g = f.geometry()
                    if not g or g.isEmpty():
                        continue
                    if g.isMultipart():
                        lines = g.asMultiPolyline()
                        pts = lines[0] if lines else []
                    else:
                        pts = g.asPolyline()
                    if len(pts) < 2:
                        continue
                    coords_by_fid[fid] = (QgsPointXY(pts[0]), QgsPointXY(pts[-1]))
                except Exception:
                    continue

            # Interpolate missing elevations
            for fid, f in features.items():
                try:
                    if fid not in coords_by_fid:
                        continue
                    p1pt, p2pt = coords_by_fid[fid]
                    # p1 elev
                    if f.attribute(p1e) in (None, '') and self._floater and self._floater._interp:
                        lyr_pt = self._floater._to_raster.transform(QgsPointXY(p1pt)) if self._floater._to_raster else None
                        elev = self._floater._interp.bilinear(lyr_pt) if lyr_pt else None
                        if elev is not None:
                            lyr.changeAttributeValue(fid, p1e, round(float(elev), 2))
                    # p2 elev
                    if f.attribute(p2e) in (None, '') and self._floater and self._floater._interp:
                        lyr_pt = self._floater._to_raster.transform(QgsPointXY(p2pt)) if self._floater._to_raster else None
                        elev = self._floater._interp.bilinear(lyr_pt) if lyr_pt else None
                        if elev is not None:
                            lyr.changeAttributeValue(fid, p2e, round(float(elev), 2))
                except Exception:
                    continue

            # Build selected subgraph indices
            def key(pt: QgsPointXY) -> str:
                return f"{pt.x():.6f},{pt.y():.6f}"
            p2_to_feats, p1_from_feats = {}, {}
            for fid, (p1pt, p2pt) in coords_by_fid.items():
                p2_to_feats.setdefault(key(p2pt), []).append(fid)
                p1_from_feats.setdefault(key(p1pt), []).append(fid)

            # Roots (no selected upstream)
            roots = [fid for fid, (p1pt, _) in coords_by_fid.items() if key(p1pt) not in p2_to_feats]

            # Parameters
            min_cover_m = float(self.spnMinCover.value()) if hasattr(self, 'spnMinCover') else 0.9
            diameter_m = (float(self.spnDiameter.value())/1000.0) if hasattr(self, 'spnDiameter') else 0.150
            slope = float(self.spnSlope.value()) if hasattr(self, 'spnSlope') else 0.005
            init_depth = float(self.spnInitialDepth.value()) if hasattr(self, 'spnInitialDepth') else 0.0

            def enforce_min_cover(ground_elev: float, proposed_bottom: float) -> float:
                min_bottom = ground_elev - (min_cover_m + diameter_m)
                return min(proposed_bottom, min_bottom)

            # Traverse
            visited = set()
            for root in roots:
                try:
                    if root not in features or root not in coords_by_fid:
                        continue
                    f = features[root]
                    p1pt, p2pt = coords_by_fid[root]
                    ge1 = f.attribute(p1e); ge2 = f.attribute(p2e)
                    ge1 = float(ge1) if ge1 not in (None, '') else None
                    ge2 = float(ge2) if ge2 not in (None, '') else None
                    if ge1 is None:
                        continue
                    p1_depth = init_depth if init_depth > 0 else (min_cover_m + diameter_m)
                    lyr.changeAttributeValue(root, p1h, round(float(p1_depth), 2))
                    seg_len = self._floater._distance_m(p1pt, p2pt)
                    upstream_bottom = ge1 - p1_depth
                    downstream_bottom = upstream_bottom - seg_len * max(0.0, slope)
                    if ge2 is not None:
                        downstream_bottom = enforce_min_cover(ge2, downstream_bottom)
                        p2_depth = ge2 - downstream_bottom
                        lyr.changeAttributeValue(root, p2h, round(float(p2_depth), 2))
                except Exception:
                    pass

                # DFS downstream
                stack = [root]
                while stack:
                    cur = stack.pop()
                    if cur in visited:
                        continue
                    visited.add(cur)
                    try:
                        _, cur_p2 = coords_by_fid[cur]
                        for nid in p1_from_feats.get(key(cur_p2), []):
                            if nid in visited or nid not in features or nid not in coords_by_fid:
                                continue
                            parent_f = features[cur]
                            nid_f = features[nid]
                            parent_p2_depth_val = parent_f.attribute(p2h)
                            if parent_p2_depth_val in (None, ''):
                                continue
                            parent_p2_depth = float(parent_p2_depth_val)
                            # set child's p1 depth
                            lyr.changeAttributeValue(nid, p1h, round(parent_p2_depth, 2))
                            # compute child's p2 depth
                            p1pt, p2pt = coords_by_fid[nid]
                            ge1 = nid_f.attribute(p1e); ge2 = nid_f.attribute(p2e)
                            ge1 = float(ge1) if ge1 not in (None, '') else None
                            ge2 = float(ge2) if ge2 not in (None, '') else None
                            if ge1 is None:
                                continue
                            seg_len = self._floater._distance_m(p1pt, p2pt)
                            upstream_bottom = ge1 - parent_p2_depth
                            downstream_bottom = upstream_bottom - seg_len * max(0.0, slope)
                            if ge2 is not None:
                                downstream_bottom = enforce_min_cover(ge2, downstream_bottom)
                                p2_depth = ge2 - downstream_bottom
                                lyr.changeAttributeValue(nid, p2h, round(float(p2_depth), 2))
                            stack.append(nid)
                    except Exception:
                        continue

            try:
                if self.iface:
                    # QGIS stable APIs: use info as success indicator
                    self.iface.messageBar().pushInfo(self.tr("Sewerage Depth Estimator"), self.tr("Recalculation complete."))
            except Exception:
                pass
        except Exception:
            try:
                if self.iface:
                    self.iface.messageBar().pushCritical(self.tr("Sewerage Depth Estimator"), self.tr("Recalculation failed."))
            except Exception:
                pass

    def _on_create_default_attrs(self):
        lyr = self._current_line_layer()
        if lyr is None:
            return
        required = ['p1_elev', 'p2_elev', 'p1_h', 'p2_h']
        existing = set([f.name() for f in lyr.fields()])
        if all(name in existing for name in required):
            # Warn already exists
            try:
                self.iface.messageBar().pushWarning(self.tr("Sewerage Depth Estimator"), self.tr("Default attributes already exist in the selected layer."))
            except Exception:
                pass
            # still reflect selection
            self._populate_numeric_fields()
            return
        # Add missing numeric fields (double)
        try:
            from qgis.PyQt.QtCore import QVariant
        except Exception:
            QVariant = None
        try:
            caps = lyr.dataProvider().capabilities()
            if not lyr.isEditable():
                lyr.startEditing()
            from qgis.core import QgsField
            for name in required:
                if name not in existing:
                    fld = QgsField(name, 6)  # QVariant.Double == 6 in many builds
                    lyr.addAttribute(fld)
            lyr.updateFields()
            lyr.commitChanges()
        except Exception:
            try:
                lyr.rollback()
            except Exception:
                pass
        # refresh selectors
        self._populate_numeric_fields()

    def _resolve_field_index(self, layer, ui_name: str, default_name: str) -> int:
        """Resolve field index from UI combo or default name"""
        try:
            if hasattr(self, ui_name):
                cb = getattr(self, ui_name)
                name = cb.currentData() if cb.currentIndex() >= 0 else default_name
            else:
                name = default_name
            return layer.fields().indexOf(name)
        except Exception:
            return -1

    # --- Display style handling -----------------------------------------------
    def _init_color_buttons(self):
        # Create color buttons in containers
        self.btnTextColor = None
        self.btnBgColor = None
        if hasattr(self, 'textColorContainer') and self.textColorContainer is not None:
            lay = QtWidgets.QHBoxLayout(self.textColorContainer)
            lay.setContentsMargins(0, 0, 0, 0)
            self.btnTextColor = QgsColorButton(self.textColorContainer)
            self.btnTextColor.setAllowOpacity(True)
            self.btnTextColor.setColor(QtGui.QColor(34, 34, 34, 255))
            self.btnTextColor.colorChanged.connect(self._on_style_changed)
            lay.addWidget(self.btnTextColor)
        if hasattr(self, 'bgColorContainer') and self.bgColorContainer is not None:
            lay2 = QtWidgets.QHBoxLayout(self.bgColorContainer)
            lay2.setContentsMargins(0, 0, 0, 0)
            self.btnBgColor = QgsColorButton(self.bgColorContainer)
            self.btnBgColor.setAllowOpacity(True)
            self.btnBgColor.setColor(QtGui.QColor(240, 240, 240, 200))
            self.btnBgColor.colorChanged.connect(self._on_style_changed)
            lay2.addWidget(self.btnBgColor)

    def _on_style_changed(self, *args):
        self._push_style_to_floater()
        self._save_project_config()

    def _push_style_to_floater(self):
        if not self._floater:
            return
        try:
            font = self.fontCombo.currentFont() if hasattr(self, 'fontCombo') else QtGui.QFont()
            size = int(self.spnFontSize.value()) if hasattr(self, 'spnFontSize') else 11
            bold_labels = bool(self.chkBoldLabels.isChecked()) if hasattr(self, 'chkBoldLabels') else True
            text_color = self.btnTextColor.color() if self.btnTextColor else QtGui.QColor(34, 34, 34)
            bg_color = self.btnBgColor.color() if self.btnBgColor else QtGui.QColor(240, 240, 240)
            layout_mode = 'vertical'
            if hasattr(self, 'cmbLabelLayout') and self.cmbLabelLayout.currentIndex() == 1:
                layout_mode = 'horizontal'
            corner = float(self.spnCornerRadius.value()) if hasattr(self, 'spnCornerRadius') else 3.5
            offx = int(self.spnOffsetX.value()) if hasattr(self, 'spnOffsetX') else 14
            offy = int(self.spnOffsetY.value()) if hasattr(self, 'spnOffsetY') else 10
            self._floater.set_style(font, size, text_color, bg_color, bold_labels)
            self._floater.set_layout_mode(layout_mode)
            self._floater.set_bubble_style(corner_radius=corner, offset_x=offx, offset_y=offy)
        except Exception:
            pass

    def _on_restore_default_style(self):
        try:
            # Defaults
            default_font = QtGui.QFont('Calibri')
            default_size = 11
            default_bold = True
            default_text = QtGui.QColor(34, 34, 34, 255)
            default_bg = QtGui.QColor(240, 240, 240, 200)
            default_layout = 'Vertical'
            default_corner = 3.5
            default_offx = 14
            default_offy = 10

            if hasattr(self, 'fontCombo'):
                self.fontCombo.setCurrentFont(default_font)
            if hasattr(self, 'spnFontSize'):
                self.spnFontSize.setValue(default_size)
            if hasattr(self, 'chkBoldLabels'):
                self.chkBoldLabels.setChecked(default_bold)
            if hasattr(self, 'btnTextColor') and self.btnTextColor:
                try:
                    self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnTextColor.setColor(default_text)
                self.btnTextColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'btnBgColor') and self.btnBgColor:
                try:
                    self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                except Exception:
                    pass
                self.btnBgColor.setColor(default_bg)
                self.btnBgColor.colorChanged.connect(self._on_style_changed)
            if hasattr(self, 'cmbLabelLayout'):
                idx = self.cmbLabelLayout.findText(default_layout)
                if idx >= 0:
                    self.cmbLabelLayout.setCurrentIndex(idx)
            if hasattr(self, 'spnCornerRadius'):
                self.spnCornerRadius.setValue(default_corner)
            if hasattr(self, 'spnOffsetX'):
                self.spnOffsetX.setValue(default_offx)
            if hasattr(self, 'spnOffsetY'):
                self.spnOffsetY.setValue(default_offy)

            # Apply and persist
            self._push_style_to_floater()
            self._save_project_config()
        except Exception:
            pass

    # Project Configuration Save/Load ----------------------------------------
    def _load_project_config(self):
        """Load plugin configuration from QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Load the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                estimate_enabled, ok = project.readBoolEntry(plugin_group, "estimate_enabled", False)
                if ok:
                    self.chkEstimateDepth.setChecked(estimate_enabled)
            
            # Load DEM layer and band
            dem_layer_id, ok = project.readEntry(plugin_group, "dem_layer_id", "")
            if ok and dem_layer_id:
                # Find layer by ID and select it
                layer = QgsProject.instance().mapLayer(dem_layer_id)
                if layer and hasattr(self, 'cmbDemLayer'):
                    for i in range(self.cmbDemLayer.count()):
                        if self.cmbDemLayer.itemData(i) == dem_layer_id:
                            self.cmbDemLayer.setCurrentIndex(i)
                            break
            
            # Load DEM band
            dem_band, ok = project.readNumEntry(plugin_group, "dem_band", 1)
            if ok and hasattr(self, 'cmbDemBand'):
                for i in range(self.cmbDemBand.count()):
                    if self.cmbDemBand.itemData(i) == dem_band:
                        self.cmbDemBand.setCurrentIndex(i)
                        break
            
            # Load sewer vector layer
            sewer_layer_id, ok = project.readEntry(plugin_group, "sewer_layer_id", "")
            if ok and sewer_layer_id:
                layer = QgsProject.instance().mapLayer(sewer_layer_id)
                if layer and hasattr(self, 'cmbLineLayer'):
                    for i in range(self.cmbLineLayer.count()):
                        if self.cmbLineLayer.itemData(i) == sewer_layer_id:
                            self.cmbLineLayer.setCurrentIndex(i)
                            break
            
            # Load parameters
            if hasattr(self, 'spnMinCover'):
                min_cover, ok = project.readDoubleEntry(plugin_group, "min_cover", 0.9)
                if ok:
                    self.spnMinCover.setValue(min_cover)
            
            if hasattr(self, 'spnDiameter'):
                diameter, ok = project.readNumEntry(plugin_group, "diameter_mm", 150)
                if ok:
                    self.spnDiameter.setValue(diameter)
            
            if hasattr(self, 'spnSlope'):
                slope, ok = project.readDoubleEntry(plugin_group, "slope", 0.005)
                if ok:
                    self.spnSlope.setValue(slope)
            
            if hasattr(self, 'spnInitialDepth'):
                initial_depth, ok = project.readDoubleEntry(plugin_group, "initial_depth", 0.0)
                if ok:
                    self.spnInitialDepth.setValue(initial_depth)
            
            # Load display settings
            if hasattr(self, 'chkShowExt'):
                show_ext, ok = project.readBoolEntry(plugin_group, "show_extension", True)
                if ok:
                    self.chkShowExt.setChecked(show_ext)
            
            if hasattr(self, 'chkShowElev'):
                show_elev, ok = project.readBoolEntry(plugin_group, "show_elevation", True)
                if ok:
                    self.chkShowElev.setChecked(show_elev)
            
            if hasattr(self, 'chkShowDepth'):
                show_depth, ok = project.readBoolEntry(plugin_group, "show_depth", True)
                if ok:
                    self.chkShowDepth.setChecked(show_depth)
            
            # Load style settings
            if hasattr(self, 'spnFontSize'):
                font_size, ok = project.readNumEntry(plugin_group, "font_size", 9)
                if ok:
                    self.spnFontSize.setValue(font_size)
            
            if hasattr(self, 'chkBoldLabels'):
                bold_labels, ok = project.readBoolEntry(plugin_group, "bold_labels", True)
                if ok:
                    self.chkBoldLabels.setChecked(bold_labels)
            
            # Load font family
            if hasattr(self, 'fontCombo'):
                font_family, ok = project.readEntry(plugin_group, "font_family", "")
                if ok and font_family:
                    try:
                        f = QtGui.QFont()
                        f.setFamily(font_family)
                        self.fontCombo.setCurrentFont(f)
                    except Exception:
                        pass

            # Load text and background colors (stored as r,g,b,a)
            try:
                text_color_str, ok = project.readEntry(plugin_group, "text_color_rgba", "")
                if ok and text_color_str and hasattr(self, 'btnTextColor') and self.btnTextColor:
                    parts = [int(p) for p in text_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnTextColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnTextColor.setColor(color)
                        # Reconnect signal
                        self.btnTextColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            try:
                bg_color_str, ok = project.readEntry(plugin_group, "bg_color_rgba", "")
                if ok and bg_color_str and hasattr(self, 'btnBgColor') and self.btnBgColor:
                    parts = [int(p) for p in bg_color_str.split(',') if p.strip() != ""]
                    if len(parts) == 4:
                        color = QtGui.QColor(parts[0], parts[1], parts[2], parts[3])
                        # Temporarily disconnect signal to avoid triggering save during load
                        self.btnBgColor.colorChanged.disconnect(self._on_style_changed)
                        self.btnBgColor.setColor(color)
                        # Reconnect signal
                        self.btnBgColor.colorChanged.connect(self._on_style_changed)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                layout_mode, ok = project.readEntry(plugin_group, "label_layout", "Vertical")
                if ok:
                    index = self.cmbLabelLayout.findText(layout_mode)
                    if index >= 0:
                        self.cmbLabelLayout.setCurrentIndex(index)
            
            if hasattr(self, 'spnCornerRadius'):
                corner_radius, ok = project.readDoubleEntry(plugin_group, "corner_radius", 3.5)
                if ok:
                    self.spnCornerRadius.setValue(corner_radius)
            
            if hasattr(self, 'spnOffsetX'):
                offset_x, ok = project.readNumEntry(plugin_group, "offset_x", 14)
                if ok:
                    self.spnOffsetX.setValue(offset_x)
            
            if hasattr(self, 'spnOffsetY'):
                offset_y, ok = project.readNumEntry(plugin_group, "offset_y", 10)
                if ok:
                    self.spnOffsetY.setValue(offset_y)
            
            # Ensure attribute combos are populated for the restored layer
            try:
                self._populate_numeric_fields()
                self._push_gate_layer_to_floater()
                # Ensure floater style reflects restored settings
                self._push_style_to_floater()
                # IMPORTANT: Restart floater with the restored DEM settings
                # This ensures the interpolator is initialized with the correct DEM
                if hasattr(self, 'chkEstimateDepth') and self.chkEstimateDepth.isChecked():
                    self._restart_floater()
            except Exception:
                pass

            print("[SEWERAGE DEBUG] Loaded project configuration")
            
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error loading project config: {e}")
    
    def _save_project_config(self):
        """Save plugin configuration to QGIS project file"""
        try:
            project = QgsProject.instance()
            plugin_group = "SewerageDepthEstimator"
            
            # Save the "Estimate network depth" checkbox state
            if hasattr(self, 'chkEstimateDepth'):
                project.writeEntry(plugin_group, "estimate_enabled", str(self.chkEstimateDepth.isChecked()))
            
            # Save DEM layer and band
            if hasattr(self, 'cmbDemLayer') and self.cmbDemLayer.currentIndex() >= 0:
                dem_layer_id = self.cmbDemLayer.currentData()
                if dem_layer_id:
                    project.writeEntry(plugin_group, "dem_layer_id", dem_layer_id)
            
            if hasattr(self, 'cmbDemBand') and self.cmbDemBand.currentIndex() >= 0:
                dem_band = self.cmbDemBand.currentData()
                if dem_band is not None:
                    project.writeEntry(plugin_group, "dem_band", str(dem_band))
            
            # Save sewer vector layer
            if hasattr(self, 'cmbLineLayer') and self.cmbLineLayer.currentIndex() >= 0:
                sewer_layer_id = self.cmbLineLayer.currentData()
                if sewer_layer_id:
                    project.writeEntry(plugin_group, "sewer_layer_id", sewer_layer_id)
            
            # Save parameters
            if hasattr(self, 'spnMinCover'):
                project.writeEntry(plugin_group, "min_cover", str(self.spnMinCover.value()))
            
            if hasattr(self, 'spnDiameter'):
                project.writeEntry(plugin_group, "diameter_mm", str(self.spnDiameter.value()))
            
            if hasattr(self, 'spnSlope'):
                project.writeEntry(plugin_group, "slope", str(self.spnSlope.value()))
            
            if hasattr(self, 'spnInitialDepth'):
                project.writeEntry(plugin_group, "initial_depth", str(self.spnInitialDepth.value()))
            
            # Save display settings
            if hasattr(self, 'chkShowExt'):
                project.writeEntry(plugin_group, "show_extension", str(self.chkShowExt.isChecked()))
            
            if hasattr(self, 'chkShowElev'):
                project.writeEntry(plugin_group, "show_elevation", str(self.chkShowElev.isChecked()))
            
            if hasattr(self, 'chkShowDepth'):
                project.writeEntry(plugin_group, "show_depth", str(self.chkShowDepth.isChecked()))
            
            # Save style settings
            if hasattr(self, 'spnFontSize'):
                project.writeEntry(plugin_group, "font_size", str(self.spnFontSize.value()))
            
            if hasattr(self, 'chkBoldLabels'):
                project.writeEntry(plugin_group, "bold_labels", str(self.chkBoldLabels.isChecked()))
            
            # Save font family
            if hasattr(self, 'fontCombo'):
                try:
                    project.writeEntry(plugin_group, "font_family", self.fontCombo.currentFont().family())
                except Exception:
                    pass

            # Save colors as r,g,b,a
            try:
                if hasattr(self, 'btnTextColor') and self.btnTextColor:
                    c = self.btnTextColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "text_color_rgba", color_str)
            except Exception:
                pass

            try:
                if hasattr(self, 'btnBgColor') and self.btnBgColor:
                    c = self.btnBgColor.color()
                    color_str = f"{c.red()},{c.green()},{c.blue()},{c.alpha()}"
                    project.writeEntry(plugin_group, "bg_color_rgba", color_str)
            except Exception:
                pass

            if hasattr(self, 'cmbLabelLayout'):
                project.writeEntry(plugin_group, "label_layout", self.cmbLabelLayout.currentText())
            
            if hasattr(self, 'spnCornerRadius'):
                project.writeEntry(plugin_group, "corner_radius", str(self.spnCornerRadius.value()))
            
            if hasattr(self, 'spnOffsetX'):
                project.writeEntry(plugin_group, "offset_x", str(self.spnOffsetX.value()))
            
            if hasattr(self, 'spnOffsetY'):
                project.writeEntry(plugin_group, "offset_y", str(self.spnOffsetY.value()))
            
            print("[SEWERAGE DEBUG] Saved project configuration")
            
        except Exception as e:
            print(f"[SEWERAGE DEBUG] Error saving project config: {e}")
